/**
 * string-match-left-right
 * Do substrings match what's on the left or right of a given index?
 * Version: 3.11.19
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-match-left-right
 */

!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((t=t||self).stringMatchLeftRight={})}(this,(function(t){"use strict";function r(t){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function e(t){return t&&"object"===r(t)&&!Array.isArray(t)}function n(t){return"string"==typeof t}function i(t,r,e,n,i,a){var o="function"==typeof e?e():e;if(r<0&&i&&"EOL"===o)return o;if(r>=t.length&&!i)return!1;for(var c=i?1:e.length,h=r;t[h];){var f=a(h);if(n.trimBeforeMatching&&""===t[h].trim()){if(!t[f]&&i&&"EOL"===e)return!0;h=a(h)}else if(!n.i&&n.trimCharsBeforeMatching.includes(t[h])||n.i&&n.trimCharsBeforeMatching.map((function(t){return t.toLowerCase()})).includes(t[h].toLowerCase())){if(i&&"EOL"===e&&!t[f])return!0;h=a(h)}else{var s=f>h?e[e.length-c]:e[c-1];if(!n.i&&t[h]===s||n.i&&t[h].toLowerCase()===s.toLowerCase()){if((c-=1)<1)return h}else{if(!n.maxMismatches)return!1;n.maxMismatches=n.maxMismatches-1}h=a(h)}}return c>0?!(!i||"EOL"!==o):void 0}function a(t,a,o,c,h){if(e(h)&&Object.prototype.hasOwnProperty.call(h,"trimBeforeMatching")&&"boolean"!=typeof h.trimBeforeMatching)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!").concat(Array.isArray(h.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));var f,s,u,m,g,l=Object.assign({},{i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!0,lastMustMatch:!0},h);if(l.trimCharsBeforeMatching="string"==typeof(f=l.trimCharsBeforeMatching)?f.length>0?[f]:[]:f,l.trimCharsBeforeMatching=l.trimCharsBeforeMatching.map((function(t){return n(t)?t:String(t)})),!n(a))return!1;if(0===a.length)return!1;if(!Number.isInteger(o)||o<0)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ").concat(r(o),", equal to:\n").concat(JSON.stringify(o,null,4)));if(n(c))s=[c];else if(Array.isArray(c))s=c;else if(c){if("function"!=typeof c)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ").concat(r(c),", equal to:\n").concat(JSON.stringify(c,null,4)));(s=[]).push(c)}else s=c;if(h&&!e(h))throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \"").concat(r(h),'", and equal to:\n').concat(JSON.stringify(h,null,4)));if(l.trimCharsBeforeMatching.some((function(t,r){return t.length>1&&(m=r,g=t,!0)})))throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ").concat(m," is longer than 1 character, ").concat(g.length," (equals to ").concat(g,"). Please split it into separate characters and put into array as separate elements."));if(!s||!Array.isArray(s)||Array.isArray(s)&&!s.length||Array.isArray(s)&&1===s.length&&n(s[0])&&0===s[0].trim().length){if("function"==typeof l.cb){var y,p=o;if("matchLeftIncl"!==t&&"matchRight"!==t||(p+=1),t.startsWith("matchLeft"))for(var b=p;b--;){var M=a[b];if((!l.trimBeforeMatching||l.trimBeforeMatching&&void 0!==M&&M.trim().length)&&(0===l.trimCharsBeforeMatching.length||void 0!==M&&!l.trimCharsBeforeMatching.includes(M))){y=b;break}}else if(t.startsWith("matchRight"))for(var d=p;d<a.length;d++){var v=a[d];if((!l.trimBeforeMatching||l.trimBeforeMatching&&v.trim().length)&&(0===l.trimCharsBeforeMatching.length||!l.trimCharsBeforeMatching.includes(v))){y=d;break}}if(void 0===y)return!1;var B=a[y],w=y+1,C="";return w&&w>0&&(C=a.slice(0,w)),t.startsWith("matchLeft")?l.cb(B,C,y):(y&&y>0&&(C=a.slice(y)),l.cb(B,C,y))}var L="";throw h||(L=" More so, the whole options object, the fourth input argument, is missing!"),new Error("string-match-left-right/".concat(t,'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!').concat(L))}if(t.startsWith("matchLeft")){for(var O=0,I=s.length;O<I;O++){u="function"==typeof s[O];var R=s[O],_=void 0,A=void 0,E="",T=o;"matchLeft"===t&&(T-=1);var W=i(a,T,R,l,u,(function(t){return t-1}));if(W&&u&&"function"==typeof R&&"EOL"===R())return!(!R()||l.cb&&!l.cb(_,E,A))&&R();if(Number.isInteger(W)&&W&&(_=a[A=W-1],E=a.slice(0,W)),Number.isInteger(W)&&(!l.cb||l.cb(_,E,A)))return R}return!1}for(var j=0,S=s.length;j<S;j++){u="function"==typeof s[j];var x=s[j],N=i(a,o+("matchRight"===t?1:0),x,l,u,(function(t){return t+1}));if(N&&u&&"function"==typeof x&&"EOL"===x())return!(!x()||l.cb&&!l.cb())&&x();var D=void 0,H=void 0;Number.isInteger(N)&&(D=N+1),a[D]&&(H=a[D]);var k="";if(Number.isInteger(D)&&D>=0&&(k=a.slice(D)),!1!==N&&(!l.cb||l.cb(H,k,D)))return x}return!1}t.matchLeft=function(t,r,e,n){return a("matchLeft",t,r,e,n)},t.matchLeftIncl=function(t,r,e,n){return a("matchLeftIncl",t,r,e,n)},t.matchRight=function(t,r,e,n){return a("matchRight",t,r,e,n)},t.matchRightIncl=function(t,r,e,n){return a("matchRightIncl",t,r,e,n)},Object.defineProperty(t,"__esModule",{value:!0})}));
