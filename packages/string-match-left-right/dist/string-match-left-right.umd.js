/**
 * string-match-left-right
 * Do substrings match what's on the left or right of a given index?
 * Version: 3.11.19
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-match-left-right
 */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).stringMatchLeftRight={})}(this,(function(t){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function r(t){return t&&"object"===e(t)&&!Array.isArray(t)}function n(t){return"string"==typeof t}function i(t,e,r,n,i,a){var o="function"==typeof r?r():r;if(e<0&&i&&"EOL"===o)return o;if(e>=t.length&&!i)return!1;for(var c=i?1:r.length,h=!1,s=!1,f=e;t[f];){var u=a(f);if(n.trimBeforeMatching&&""===t[f].trim()){if(!t[u]&&i&&"EOL"===r)return!0;f=a(f)}else if(!n.i&&n.trimCharsBeforeMatching.includes(t[f])||n.i&&n.trimCharsBeforeMatching.map((function(t){return t.toLowerCase()})).includes(t[f].toLowerCase())){if(i&&"EOL"===r&&!t[u])return!0;f=a(f)}else{var l=u>f?r[r.length-c]:r[c-1];if(!n.i&&t[f]===l||n.i&&t[f].toLowerCase()===l.toLowerCase()){if(s||(s=!0),(c-=1)<1)return f}else if(!1!==h){var g=u>f?r[r.length-c-1]:r[c-2];if(g&&(!n.i&&t[f]===g||n.i&&t[f].toLowerCase()===g.toLowerCase()))c-=2;else if(1===c&&s)return h}else{if(!n.maxMismatches||!f)return!(0!==f||1!==c||!s)&&0;n.maxMismatches=n.maxMismatches-1;var m=u>f?r[r.length-c+1]:r[c-2];!n.i&&t[f]===m||n.i&&t[f].toLowerCase()===m.toLowerCase()?c-=2:h=f}if(!1!==h&&h!==f&&(h=!1),c<1)return f;f=a(f)}}return c>0?!(!i||"EOL"!==o)||n.maxMismatches>=c&&(h||0):void 0}function a(t,a,o,c,h){if(r(h)&&Object.prototype.hasOwnProperty.call(h,"trimBeforeMatching")&&"boolean"!=typeof h.trimBeforeMatching)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!").concat(Array.isArray(h.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));var s,f,u,l,g,m=Object.assign({},{i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!0,lastMustMatch:!0},h);if(m.trimCharsBeforeMatching="string"==typeof(s=m.trimCharsBeforeMatching)?s.length>0?[s]:[]:s,m.trimCharsBeforeMatching=m.trimCharsBeforeMatching.map((function(t){return n(t)?t:String(t)})),!n(a))return!1;if(!a.length)return!1;if(!Number.isInteger(o)||o<0)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ").concat(e(o),", equal to:\n").concat(JSON.stringify(o,null,4)));if(n(c))f=[c];else if(Array.isArray(c))f=c;else if(c){if("function"!=typeof c)throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ").concat(e(c),", equal to:\n").concat(JSON.stringify(c,null,4)));(f=[]).push(c)}else f=c;if(h&&!r(h))throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \"").concat(e(h),'", and equal to:\n').concat(JSON.stringify(h,null,4)));if(m.trimCharsBeforeMatching.some((function(t,e){return t.length>1&&(l=e,g=t,!0)})))throw new Error("string-match-left-right/".concat(t,"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ").concat(l," is longer than 1 character, ").concat(g.length," (equals to ").concat(g,"). Please split it into separate characters and put into array as separate elements."));if(!f||!Array.isArray(f)||Array.isArray(f)&&!f.length||Array.isArray(f)&&1===f.length&&n(f[0])&&!f[0].trim().length){if("function"==typeof m.cb){var y,p=o;if("matchLeftIncl"!==t&&"matchRight"!==t||(p+=1),"L"===t[5])for(var b=p;b--;){var M=a[b];if((!m.trimBeforeMatching||m.trimBeforeMatching&&void 0!==M&&M.trim().length)&&(!m.trimCharsBeforeMatching.length||void 0!==M&&!m.trimCharsBeforeMatching.includes(M))){y=b;break}}else if(t.startsWith("matchRight"))for(var d=p;d<a.length;d++){var w=a[d];if((!m.trimBeforeMatching||m.trimBeforeMatching&&w.trim().length)&&(!m.trimCharsBeforeMatching.length||!m.trimCharsBeforeMatching.includes(w))){y=d;break}}if(void 0===y)return!1;var v=a[y],L=y+1,B="";return L&&L>0&&(B=a.slice(0,L)),"L"===t[5]?m.cb(v,B,y):(y&&y>0&&(B=a.slice(y)),m.cb(v,B,y))}var C="";throw h||(C=" More so, the whole options object, the fourth input argument, is missing!"),new Error("string-match-left-right/".concat(t,'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!').concat(C))}for(var O=0,I=f.length;O<I;O++){u="function"==typeof f[O];var R=f[O],_=void 0,A=void 0,E="",T=o;"matchRight"===t?T++:"matchLeft"===t&&T--;var j=i(a,T,R,m,u,(function(e){return"L"===t[5]?e-1:e+1}));if(j&&u&&"function"==typeof R&&"EOL"===R())return!(!R()||m.cb&&!m.cb(_,E,A))&&R();if(Number.isInteger(j)&&(A=t.startsWith("matchLeft")?j-1:j+1,E="L"===t[5]?a.slice(0,j):a.slice(A)),A<0&&(A=void 0),a[A]&&(_=a[A]),Number.isInteger(j)&&(!m.cb||m.cb(_,E,A)))return R}return!1}t.matchLeft=function(t,e,r,n){return a("matchLeft",t,e,r,n)},t.matchLeftIncl=function(t,e,r,n){return a("matchLeftIncl",t,e,r,n)},t.matchRight=function(t,e,r,n){return a("matchRight",t,e,r,n)},t.matchRightIncl=function(t,e,r,n){return a("matchRightIncl",t,e,r,n)},Object.defineProperty(t,"__esModule",{value:!0})}));
