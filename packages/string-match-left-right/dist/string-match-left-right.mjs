/**
 * string-match-left-right
 * Match substrings on the left or right of a given index, ignoring whitespace
 * Version: 6.0.5
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-match-left-right/
 */

import{arrayiffy as t}from"arrayiffy-if-string";function e(t){return t&&"object"==typeof t&&!Array.isArray(t)}function r(t){return"string"==typeof t}const i={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1},n=t=>t+1;function a(t,e,r,a,o=!1,s=n){const h="function"==typeof r?r():r;if(+e<0&&o&&"EOL"===h)return h;const c={...i,...a};if(e>=t.length&&!o)return!1;let f=o?1:r.length,g=0,l=!1,m=!1,u=!1,M=c.maxMismatches,y=e,p=!1,b=!1,B=!1;for(;t[y];){const e=s(y);if(c.trimBeforeMatching&&""===t[y].trim()){if(!t[e]&&o&&"EOL"===r)return!0;y=s(y);continue}if(c&&!c.i&&c.trimCharsBeforeMatching&&c.trimCharsBeforeMatching.includes(t[y])||c&&c.i&&c.trimCharsBeforeMatching&&c.trimCharsBeforeMatching.map((t=>t.toLowerCase())).includes(t[y].toLowerCase())){if(o&&"EOL"===r&&!t[e])return!0;y=s(y);continue}const i=e>y?r[r.length-f]:r[f-1];if(!c.i&&t[y]===i||c.i&&t[y].toLowerCase()===i.toLowerCase()){if(p||(p=!0),u||(u=!0),f===r.length){if(b=!0,M!==c.maxMismatches)return!1}else 1===f&&(B=!0);if(f-=1,g++,!f)return(g!==r.length||M===c.maxMismatches||!l)&&y}else{if(l||g||(l=!0),!(c.maxMismatches&&M&&y))return!(0!==y||1!==f||c.lastMustMatch||!u)&&0;M-=1;for(let i=0;i<=M;i++){const n=e>y?r[r.length-f+1+i]:r[f-2-i],a=t[s(y)];if(n&&(!c.i&&t[y]===n||c.i&&t[y].toLowerCase()===n.toLowerCase())&&(!c.firstMustMatch||f!==r.length)){f-=2,p=!0;break}if(a&&n&&(!c.i&&a===n||c.i&&a.toLowerCase()===n.toLowerCase())&&(!c.firstMustMatch||f!==r.length)){f-=1,p=!0;break}if(void 0===n&&M>=0&&p&&(!c.firstMustMatch||b)&&(!c.lastMustMatch||B))return y}p||(m=y)}if(!1!==m&&m!==y&&(m=!1),f<1)return y;y=s(y)}return f>0?!(!o||"EOL"!==h)||!!(c&&c.maxMismatches>=f&&u)&&(m||0):void 0}function o(n,o,s,h,c){if(e(c)&&Object.prototype.hasOwnProperty.call(c,"trimBeforeMatching")&&"boolean"!=typeof c.trimBeforeMatching)throw new Error(`string-match-left-right/${n}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(c.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);const f={...i,...c};if("string"==typeof f.trimCharsBeforeMatching&&(f.trimCharsBeforeMatching=t(f.trimCharsBeforeMatching)),f.trimCharsBeforeMatching=f.trimCharsBeforeMatching.map((t=>r(t)?t:String(t))),!r(o))return!1;if(!o.length)return!1;if(!Number.isInteger(s)||s<0)throw new Error(`string-match-left-right/${n}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof s}, equal to:\n${JSON.stringify(s,null,4)}`);let g,l;if(r(h))g=[h];else if(Array.isArray(h))g=h;else if(h){if("function"!=typeof h)throw new Error(`string-match-left-right/${n}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof h}, equal to:\n${JSON.stringify(h,null,4)}`);g=[],g.push(h)}else g=h;if(c&&!e(c))throw new Error(`string-match-left-right/${n}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof c}", and equal to:\n${JSON.stringify(c,null,4)}`);let m=0,u="";if(f&&f.trimCharsBeforeMatching&&f.trimCharsBeforeMatching.some(((t,e)=>t.length>1&&(m=e,u=t,!0))))throw new Error(`string-match-left-right/${n}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${m} is longer than 1 character, ${u.length} (equals to ${u}). Please split it into separate characters and put into array as separate elements.`);if(!g||!Array.isArray(g)||Array.isArray(g)&&!g.length||Array.isArray(g)&&1===g.length&&r(g[0])&&!g[0].trim()){if("function"==typeof f.cb){let t,e=s;if("matchLeftIncl"!==n&&"matchRight"!==n||(e+=1),"L"===n[5])for(let r=e;r--;){const e=o[r];if((!f.trimBeforeMatching||f.trimBeforeMatching&&void 0!==e&&e.trim())&&(!f.trimCharsBeforeMatching||!f.trimCharsBeforeMatching.length||void 0!==e&&!f.trimCharsBeforeMatching.includes(e))){t=r;break}}else if(n.startsWith("matchRight"))for(let r=e;r<o.length;r++){const e=o[r];if((!f.trimBeforeMatching||f.trimBeforeMatching&&e.trim())&&(!f.trimCharsBeforeMatching||!f.trimCharsBeforeMatching.length||!f.trimCharsBeforeMatching.includes(e))){t=r;break}}if(void 0===t)return!1;const r=o[t],i=t+1;let a="";return i&&i>0&&(a=o.slice(0,i)),"L"===n[5]?f.cb(r,a,t):(t&&t>0&&(a=o.slice(t)),f.cb(r,a,t))}let t="";throw c||(t=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${n}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${t}`)}for(let t=0,e=g.length;t<e;t++){l="function"==typeof g[t];const e=g[t];let r,i,h="",c=s;"matchRight"===n?c+=1:"matchLeft"===n&&(c-=1);const m=a(o,c,e,f,l,(t=>"L"===n[5]?t-1:t+1));if(m&&l&&"function"==typeof e&&"EOL"===e())return!(!e()||f.cb&&!f.cb(r,h,i))&&e();if(Number.isInteger(m)&&(i=n.startsWith("matchLeft")?m-1:m+1,h="L"===n[5]?o.slice(0,m):o.slice(i)),i<0&&(i=void 0),o[i]&&(r=o[i]),Number.isInteger(m)&&(!f.cb||f.cb(r,h,i)))return e}return!1}function s(t,e,r,i){return o("matchLeftIncl",t,e,r,i)}function h(t,e,r,i){return o("matchLeft",t,e,r,i)}function c(t,e,r,i){return o("matchRightIncl",t,e,r,i)}function f(t,e,r,i){return o("matchRight",t,e,r,i)}export{h as matchLeft,s as matchLeftIncl,f as matchRight,c as matchRightIncl};
