/**
 * string-match-left-right
 * Match substrings on the left or right of a given index, ignoring whitespace
 * Version: 5.0.0
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-match-left-right/
 */

import{arrayiffy as t}from"arrayiffy-if-string";function r(t){return t&&"object"==typeof t&&!Array.isArray(t)}function e(t){return"string"==typeof t}const i={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1};function n(t,r,e,i,n,a){const o="function"==typeof e?e():e;if(r<0&&n&&"EOL"===o)return o;if(r>=t.length&&!n)return!1;let s=n?1:e.length,h=!1,c=!1,f=i.maxMismatches,g=r,l=!1,u=!1,m=!1;for(;t[g];){const r=a(g);if(i.trimBeforeMatching&&""===t[g].trim()){if(!t[r]&&n&&"EOL"===e)return!0;g=a(g);continue}if(i&&!i.i&&i.trimCharsBeforeMatching&&i.trimCharsBeforeMatching.includes(t[g])||i&&i.i&&i.trimCharsBeforeMatching&&i.trimCharsBeforeMatching.map((t=>t.toLowerCase())).includes(t[g].toLowerCase())){if(n&&"EOL"===e&&!t[r])return!0;g=a(g);continue}const o=r>g?e[e.length-s]:e[s-1];if(!i.i&&t[g]===o||i.i&&t[g].toLowerCase()===o.toLowerCase()){if(l||(l=!0),c||(c=!0),s===e.length?u=!0:1===s&&(m=!0),s-=1,s<1)return g}else{if(!(i.maxMismatches&&f&&g))return!(0!==g||1!==s||i.lastMustMatch||!c)&&0;f-=1;for(let n=0;n<=f;n++){const o=r>g?e[e.length-s+1+n]:e[s-2-n],h=t[a(g)];if(o&&(!i.i&&t[g]===o||i.i&&t[g].toLowerCase()===o.toLowerCase())&&(!i.firstMustMatch||s!==e.length)){s-=2,l=!0;break}if(h&&o&&(!i.i&&h===o||i.i&&h.toLowerCase()===o.toLowerCase())&&(!i.firstMustMatch||s!==e.length)){s-=1,l=!0;break}if(void 0===o&&f>=0&&l&&(!i.firstMustMatch||u)&&(!i.lastMustMatch||m))return g}l||(h=g)}if(!1!==h&&h!==g&&(h=!1),s<1)return g;g=a(g)}return s>0?!(!n||"EOL"!==o)||!!(i&&i.maxMismatches>=s&&c)&&(h||0):void 0}function a(a,o,s,h,c){if(r(c)&&Object.prototype.hasOwnProperty.call(c,"trimBeforeMatching")&&"boolean"!=typeof c.trimBeforeMatching)throw new Error(`string-match-left-right/${a}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(c.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);const f={...i,...c};if(f.trimCharsBeforeMatching=t(f.trimCharsBeforeMatching)||[],f.trimCharsBeforeMatching=f.trimCharsBeforeMatching.map((t=>e(t)?t:String(t))),!e(o))return!1;if(!o.length)return!1;if(!Number.isInteger(s)||s<0)throw new Error(`string-match-left-right/${a}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof s}, equal to:\n${JSON.stringify(s,null,4)}`);let g,l;if(e(h))g=[h];else if(Array.isArray(h))g=h;else if(h){if("function"!=typeof h)throw new Error(`string-match-left-right/${a}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof h}, equal to:\n${JSON.stringify(h,null,4)}`);g=[],g.push(h)}else g=h;if(c&&!r(c))throw new Error(`string-match-left-right/${a}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof c}", and equal to:\n${JSON.stringify(c,null,4)}`);let u=0,m="";if(f&&f.trimCharsBeforeMatching&&f.trimCharsBeforeMatching.some(((t,r)=>t.length>1&&(u=r,m=t,!0))))throw new Error(`string-match-left-right/${a}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${u} is longer than 1 character, ${m.length} (equals to ${m}). Please split it into separate characters and put into array as separate elements.`);if(!g||!Array.isArray(g)||Array.isArray(g)&&!g.length||Array.isArray(g)&&1===g.length&&e(g[0])&&!g[0].trim()){if("function"==typeof f.cb){let t,r=s;if("matchLeftIncl"!==a&&"matchRight"!==a||(r+=1),"L"===a[5])for(let e=r;e--;){const r=o[e];if((!f.trimBeforeMatching||f.trimBeforeMatching&&void 0!==r&&r.trim())&&(!f.trimCharsBeforeMatching||!f.trimCharsBeforeMatching.length||void 0!==r&&!f.trimCharsBeforeMatching.includes(r))){t=e;break}}else if(a.startsWith("matchRight"))for(let e=r;e<o.length;e++){const r=o[e];if((!f.trimBeforeMatching||f.trimBeforeMatching&&r.trim())&&(!f.trimCharsBeforeMatching||!f.trimCharsBeforeMatching.length||!f.trimCharsBeforeMatching.includes(r))){t=e;break}}if(void 0===t)return!1;const e=o[t],i=t+1;let n="";return i&&i>0&&(n=o.slice(0,i)),"L"===a[5]?f.cb(e,n,t):(t&&t>0&&(n=o.slice(t)),f.cb(e,n,t))}let t="";throw c||(t=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${a}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${t}`)}for(let t=0,r=g.length;t<r;t++){l="function"==typeof g[t];const r=g[t];let e,i,h="",c=s;"matchRight"===a?c+=1:"matchLeft"===a&&(c-=1);const u=n(o,c,r,f,l,(t=>"L"===a[5]?t-1:t+1));if(u&&l&&"function"==typeof r&&"EOL"===r())return!(!r()||f.cb&&!f.cb(e,h,i))&&r();if(Number.isInteger(u)&&(i=a.startsWith("matchLeft")?u-1:u+1,h="L"===a[5]?o.slice(0,u):o.slice(i)),i<0&&(i=void 0),o[i]&&(e=o[i]),Number.isInteger(u)&&(!f.cb||f.cb(e,h,i)))return r}return!1}function o(t,r,e,i){return a("matchLeftIncl",t,r,e,i)}function s(t,r,e,i){return a("matchLeft",t,r,e,i)}function h(t,r,e,i){return a("matchRightIncl",t,r,e,i)}function c(t,r,e,i){return a("matchRight",t,r,e,i)}export{s as matchLeft,o as matchLeftIncl,c as matchRight,h as matchRightIncl};
