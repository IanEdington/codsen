/**
 * string-find-heads-tails
 * Finds where are arbitrary templating marker heads and tails located
 * Version: 3.17.0
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-find-heads-tails/
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).stringFindHeadsTails={})}(this,(function(e){"use strict";function t(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function r(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function n(e){for(var n=1;arguments.length>n;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?r(Object(i),!0).forEach((function(r){t(e,r,i[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function i(e){return"string"==typeof e?e.length?[e]:[]:e}function a(e){return e&&"object"==typeof e&&!Array.isArray(e)}function o(e){return"string"==typeof e}var s={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1};function h(e,t,r,n,i,a){var o="function"==typeof r?r():r;if(0>t&&i&&"EOL"===o)return o;if(t>=e.length&&!i)return!1;for(var s=i?1:r.length,h=!1,f=!1,l=n.maxMismatches,u=t,c=!1,g=!1,d=!1;e[u];){var m=a(u);if(n.trimBeforeMatching&&""===e[u].trim()){if(!e[m]&&i&&"EOL"===r)return!0;u=a(u)}else if(n&&!n.i&&n.trimCharsBeforeMatching&&n.trimCharsBeforeMatching.includes(e[u])||n&&n.i&&n.trimCharsBeforeMatching&&n.trimCharsBeforeMatching.map((function(e){return e.toLowerCase()})).includes(e[u].toLowerCase())){if(i&&"EOL"===r&&!e[m])return!0;u=a(u)}else{var y=m>u?r[r.length-s]:r[s-1];if(!n.i&&e[u]===y||n.i&&e[u].toLowerCase()===y.toLowerCase()){if(c||(c=!0),f||(f=!0),s===r.length?g=!0:1===s&&(d=!0),1>(s-=1))return u}else{if(!(n.maxMismatches&&l&&u))return!(0!==u||1!==s||n.lastMustMatch||!f)&&0;l-=1;for(var p=0;l>=p;p++){var w=m>u?r[r.length-s+1+p]:r[s-2-p],b=e[a(u)];if(w&&(!n.i&&e[u]===w||n.i&&e[u].toLowerCase()===w.toLowerCase())&&(!n.firstMustMatch||s!==r.length)){s-=2,c=!0;break}if(b&&w&&(!n.i&&b===w||n.i&&b.toLowerCase()===w.toLowerCase())&&(!n.firstMustMatch||s!==r.length)){s-=1,c=!0;break}if(void 0===w&&l>=0&&c&&(!n.firstMustMatch||g)&&(!n.lastMustMatch||d))return u}c||(h=u)}if(!1!==h&&h!==u&&(h=!1),1>s)return u;u=a(u)}}return s>0?!(!i||"EOL"!==o)||!(!n||s>n.maxMismatches||!f)&&(h||0):void 0}function f(e,t,r,f){return function(e,t,r,f,l){if(a(l)&&Object.prototype.hasOwnProperty.call(l,"trimBeforeMatching")&&"boolean"!=typeof l.trimBeforeMatching)throw Error("string-match-left-right/"+e+"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!"+(Array.isArray(l.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));var u,c,g=n(n({},s),l);if(g.trimCharsBeforeMatching=i(g.trimCharsBeforeMatching)||[],g.trimCharsBeforeMatching=g.trimCharsBeforeMatching.map((function(e){return o(e)?e:e+""})),!o(t))return!1;if(!t.length)return!1;if(!Number.isInteger(r)||0>r)throw Error("string-match-left-right/"+e+"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: "+typeof r+", equal to:\n"+JSON.stringify(r,null,4));if(o(f))u=[f];else if(Array.isArray(f))u=f;else if(f){if("function"!=typeof f)throw Error("string-match-left-right/"+e+"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's "+typeof f+", equal to:\n"+JSON.stringify(f,null,4));(u=[]).push(f)}else u=f;if(l&&!a(l))throw Error("string-match-left-right/"+e+"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \""+typeof l+'", and equal to:\n'+JSON.stringify(l,null,4));var d=0,m="";if(g&&g.trimCharsBeforeMatching&&g.trimCharsBeforeMatching.some((function(e,t){return e.length>1&&(d=t,m=e,!0)})))throw Error("string-match-left-right/"+e+"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index "+d+" is longer than 1 character, "+m.length+" (equals to "+m+"). Please split it into separate characters and put into array as separate elements.");if(!u||!Array.isArray(u)||Array.isArray(u)&&!u.length||Array.isArray(u)&&1===u.length&&o(u[0])&&!u[0].trim()){if("function"==typeof g.cb){var y,p=r;if("matchLeftIncl"!==e&&"matchRight"!==e||(p+=1),"L"===e[5])for(var w=p;w--;){var b=t[w];if((!g.trimBeforeMatching||g.trimBeforeMatching&&void 0!==b&&b.trim())&&(!g.trimCharsBeforeMatching||!g.trimCharsBeforeMatching.length||void 0!==b&&!g.trimCharsBeforeMatching.includes(b))){y=w;break}}else if(e.startsWith("matchRight"))for(var O=p;t.length>O;O++){var I=t[O];if((!g.trimBeforeMatching||g.trimBeforeMatching&&I.trim())&&(!g.trimCharsBeforeMatching||!g.trimCharsBeforeMatching.length||!g.trimCharsBeforeMatching.includes(I))){y=O;break}}if(void 0===y)return!1;var T=t[y],v=y+1,M="";return v&&v>0&&(M=t.slice(0,v)),"L"===e[5]||y&&y>0&&(M=t.slice(y)),g.cb(T,M,y)||!1}var A="";throw l||(A=" More so, the whole options object, the fourth input argument, is missing!"),Error("string-match-left-right/"+e+'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!'+A)}for(var _=0,W=u.length;W>_;_++){var C=u[_],x=void 0,B=void 0,D="",E=r;"matchRight"===e?E+=1:"matchLeft"===e&&(E-=1);var H=h(t,E,C,g,c="function"==typeof u[_],(function(t){return"L"===e[5]?t-1:t+1}));if(H&&c&&"function"==typeof C&&"EOL"===C())return!(!C()||g.cb&&!g.cb(x,D,B))&&C();if(Number.isInteger(H)&&(B=e.startsWith("matchLeft")?H-1:H+1,D="L"===e[5]?t.slice(0,H):t.slice(B)),0>B&&(B=void 0),t[B]&&(x=t[B]),Number.isInteger(H)&&(!g.cb||g.cb(x,D,B)))return C}return!1}("matchRightIncl",e,t,r,f)}function l(e){return"string"==typeof e}var u={fromIndex:0,throwWhenSomethingWrongIsDetected:!0,allowWholeValueToBeOnlyHeadsOrTails:!0,source:"string-find-heads-tails",matchHeadsAndTailsStrictlyInPairsByTheirOrder:!1,relaxedAPI:!1};e.defaults=u,e.strFindHeadsTails=function(e,t,r,a){if(a&&(!(o=a)||"object"!=typeof o||Array.isArray(o)))throw new TypeError("string-find-heads-tails: [THROW_ID_01] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: "+a+" (type: "+typeof a+")");var o,s,h,c=n(n({},u),a);if("string"==typeof c.fromIndex&&/^\d*$/.test(c.fromIndex))c.fromIndex=Number(c.fromIndex);else if(!Number.isInteger(c.fromIndex)||0>c.fromIndex)throw new TypeError(c.source+" [THROW_ID_18] the fourth input argument must be a natural number or zero! Currently it's: "+c.fromIndex);if(!l(e)||0===e.length){if(c.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_02] the first input argument, input string, must be a non-zero-length string! Currently it's: "+typeof e+", equal to: "+e)}if("string"!=typeof t&&!Array.isArray(t)){if(c.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_03] the second input argument, heads, must be either a string or an array of strings! Currently it's: "+typeof t+", equal to:\n"+JSON.stringify(t,null,4))}if("string"==typeof t){if(0===t.length){if(c.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_04] the second input argument, heads, must be a non-empty string! Currently it's empty.")}t=i(t)}else if(Array.isArray(t)){if(0===t.length){if(c.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_05] the second input argument, heads, must be a non-empty array and contain at least one string! Currently it's empty.")}if(t.every((function(e,t){return s=e,h=t,l(e)}))){if(!t.every((function(e,t){return h=t,l(e)&&e.length>0&&""!==e.trim()}))){if(!c.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_07] the second input argument, heads, should not contain empty strings! For example, there's one detected at index "+h+" of heads array:\n"+JSON.stringify(t,null,4)+".");if(0===(t=t.filter((function(e){return l(e)&&e.length>0}))).length)return[]}}else{if(!c.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_06] the second input argument, heads, contains non-string elements! For example, element at "+h+"th index is "+typeof s+", equal to:\n"+JSON.stringify(s,null,4)+". Whole heads array looks like:\n"+JSON.stringify(t,null,4));if(0===(t=t.filter((function(e){return l(e)&&e.length>0}))).length)return[]}}if(!l(r)&&!Array.isArray(r)){if(c.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_08] the third input argument, tails, must be either a string or an array of strings! Currently it's: "+typeof r+", equal to:\n"+JSON.stringify(r,null,4))}if(l(r)){if(0===r.length){if(c.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_09] the third input argument, tails, must be a non-empty string! Currently it's empty.")}r=i(r)}else if(Array.isArray(r)){if(0===r.length){if(c.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_10] the third input argument, tails, must be a non-empty array and contain at least one string! Currently it's empty.")}if(r.every((function(e,t){return s=e,h=t,l(e)}))){if(!r.every((function(e,t){return h=t,l(e)&&e.length>0&&""!==e.trim()}))){if(!c.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_12] the third input argument, tails, should not contain empty strings! For example, there's one detected at index "+h+". Whole tails array is equal to:\n"+JSON.stringify(r,null,4));if(0===(r=r.filter((function(e){return l(e)&&e.length>0}))).length)return[]}}else{if(!c.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_11] the third input argument, tails, contains non-string elements! For example, element at "+h+"th index is "+typeof s+", equal to:\n"+JSON.stringify(s,null,4)+". Whole tails array is equal to:\n"+JSON.stringify(r,null,4));if(0===(r=r.filter((function(e){return l(e)&&e.length>0}))).length)return[]}}var g=c.source===u.source;if(c.throwWhenSomethingWrongIsDetected&&!c.allowWholeValueToBeOnlyHeadsOrTails){if(i(t).includes(e))throw Error(c.source+(g?": [THROW_ID_16]":"")+" the whole input string can't be equal to "+(l(t)?"":"one of ")+"heads ("+e+")!");if(i(r).includes(e))throw Error(c.source+(g?": [THROW_ID_17]":"")+" the whole input string can't be equal to "+(l(r)?"":"one of ")+"tails ("+e+")!")}for(var d,m=t.concat(r).map((function(e){return e.charAt(0)})).reduce((function(e,t){return t.charCodeAt(0)>e[1]?[e[0],t.charCodeAt(0)]:t.charCodeAt(0)<e[0]?[t.charCodeAt(0),e[1]]:e}),[t[0].charCodeAt(0),t[0].charCodeAt(0)]),y=[],p=!1,w={},b="",O=c.fromIndex,I=e.length;I>O;O++){var T=e[O].charCodeAt(0);if(m[1]>=T&&T>=m[0]){var v=f(e,O,t);if(v&&c.matchHeadsAndTailsStrictlyInPairsByTheirOrder)for(var M=t.length;M--;)if(t[M]===v){d=M;break}if(v){if(!p){(w={}).headsStartAt=O,w.headsEndAt=O+v.length,p=!0,O+=v.length-1,b&&(b="");continue}if(c.throwWhenSomethingWrongIsDetected)throw new TypeError(c.source+(g?": [THROW_ID_19]":"")+' When processing "'+e+'", we found heads ('+e.slice(O,O+v.length)+') starting at character with index number "'+O+'" and there was another set of heads before it! Generally speaking, there should be "heads-tails-heads-tails", not "heads-heads-tails"!\nWe\'re talking about the area of the code:\n\n\n--------------------------------------starts\n'+e.slice(Math.max(O-200,0),O)+"\n      [33m-------\x3e[39m [31m"+e.slice(O,O+v.length)+"[39m [33m<-------[39m\n"+e.slice(O+v.length,Math.min(I,O+200))+"\n--------------------------------------ends\n\n\nTo turn off this error being thrown, set opts.throwWhenSomethingWrongIsDetected to Boolean false.")}var A=f(e,O,r);if(p&&A&&c.matchHeadsAndTailsStrictlyInPairsByTheirOrder&&void 0!==d&&void 0!==r[d]&&r[d]!==A){for(var _=void 0,W=r.length;W--;)if(r[W]===A){_=W;break}throw new TypeError(c.source+(g?": [THROW_ID_20]":"")+' When processing "'+e+'", we had "opts.matchHeadsAndTailsStrictlyInPairsByTheirOrder" on. We found heads ('+t[d]+") but the tails the followed it were not of the same index, "+d+" ("+r[d]+") but "+_+" ("+A+").")}if(A){if(p){w.tailsStartAt=O,w.tailsEndAt=O+A.length,y.push(w),w={},p=!1,O+=A.length-1;continue}c.throwWhenSomethingWrongIsDetected&&(b=c.source+(g?": [THROW_ID_21]":"")+' When processing "'+e+'", we found tails ('+e.slice(O,O+A.length)+') starting at character with index number "'+O+"\" but there were no heads preceding it. That's very naughty!")}}if(c.throwWhenSomethingWrongIsDetected&&O===I-1){if(0!==Object.keys(w).length)throw new TypeError(c.source+(g?": [THROW_ID_22]":"")+' When processing "'+e+"\", we reached the end of the string and yet didn't find any tails ("+JSON.stringify(r,null,4)+") to match the last detected heads ("+e.slice(w.headsStartAt,w.headsEndAt)+")!");if(b)throw Error(b)}}return y},e.version="3.17.0",Object.defineProperty(e,"__esModule",{value:!0})}));
