/**
 * string-find-heads-tails
 * Search for string pairs. A special case of string search algorithm.
 * Version: 3.16.7
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-find-heads-tails
 */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).stringFindHeadsTails=e()}(this,(function(){"use strict";function t(e){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(e)}function e(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function r(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function n(t){return"string"==typeof t?t.length>0?[t]:[]:t}function i(t){return t&&"object"==typeof t&&!Array.isArray(t)}function o(t){return"string"==typeof t}function a(t,e,r,n,i,o){const a="function"==typeof r?r():r;if(e<0&&i&&"EOL"===a)return a;if(e>=t.length&&!i)return!1;let s=i?1:r.length,c=!1,h=!1,l=n.maxMismatches,f=e,u=!1,g=!1,d=!1;for(;t[f];){const e=o(f);if(n.trimBeforeMatching&&""===t[f].trim()){if(!t[e]&&i&&"EOL"===r)return!0;f=o(f);continue}if(!n.i&&n.trimCharsBeforeMatching.includes(t[f])||n.i&&n.trimCharsBeforeMatching.map(t=>t.toLowerCase()).includes(t[f].toLowerCase())){if(i&&"EOL"===r&&!t[e])return!0;f=o(f);continue}const a=e>f?r[r.length-s]:r[s-1];if(!n.i&&t[f]===a||n.i&&t[f].toLowerCase()===a.toLowerCase()){if(u||(u=!0),h||(h=!0),s===r.length?g=!0:1===s&&(d=!0),s-=1,s<1)return f}else{if(!(n.maxMismatches&&l&&f))return!(0!==f||1!==s||n.lastMustMatch||!h)&&0;l-=1;for(let i=0;i<=l;i++){const a=e>f?r[r.length-s+1+i]:r[s-2-i],c=t[o(f)];if(a&&(!n.i&&t[f]===a||n.i&&t[f].toLowerCase()===a.toLowerCase())&&(!n.firstMustMatch||s!==r.length)){s-=2,u=!0;break}if(c&&a&&(!n.i&&c===a||n.i&&c.toLowerCase()===a.toLowerCase())&&(!n.firstMustMatch||s!==r.length)){s-=1,u=!0;break}if(void 0===a&&l>=0&&u&&(!n.firstMustMatch||g)&&(!n.lastMustMatch||d))return f}u||(c=f)}if(!1!==c&&c!==f&&(c=!1),s<1)return f;f=o(f)}return s>0?!(!i||"EOL"!==a)||!!(n.maxMismatches>=s&&h)&&(c||0):void 0}function s(t,e,r,s){return function(t,e,r,s,c){if(i(c)&&Object.prototype.hasOwnProperty.call(c,"trimBeforeMatching")&&"boolean"!=typeof c.trimBeforeMatching)throw new Error(`string-match-left-right/${t}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(c.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);const h={i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1,...c};if(h.trimCharsBeforeMatching=n(h.trimCharsBeforeMatching),h.trimCharsBeforeMatching=h.trimCharsBeforeMatching.map(t=>o(t)?t:String(t)),!o(e))return!1;if(!e.length)return!1;if(!Number.isInteger(r)||r<0)throw new Error(`string-match-left-right/${t}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof r}, equal to:\n${JSON.stringify(r,null,4)}`);let l,f,u,g;if(o(s))l=[s];else if(Array.isArray(s))l=s;else if(s){if("function"!=typeof s)throw new Error(`string-match-left-right/${t}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof s}, equal to:\n${JSON.stringify(s,null,4)}`);l=[],l.push(s)}else l=s;if(c&&!i(c))throw new Error(`string-match-left-right/${t}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof c}", and equal to:\n${JSON.stringify(c,null,4)}`);if(h.trimCharsBeforeMatching.some((t,e)=>t.length>1&&(u=e,g=t,!0)))throw new Error(`string-match-left-right/${t}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${u} is longer than 1 character, ${g.length} (equals to ${g}). Please split it into separate characters and put into array as separate elements.`);if(!l||!Array.isArray(l)||Array.isArray(l)&&!l.length||Array.isArray(l)&&1===l.length&&o(l[0])&&!l[0].trim()){if("function"==typeof h.cb){let n,i=r;if("matchLeftIncl"!==t&&"matchRight"!==t||(i+=1),"L"===t[5])for(let t=i;t--;){const r=e[t];if((!h.trimBeforeMatching||h.trimBeforeMatching&&void 0!==r&&r.trim())&&(!h.trimCharsBeforeMatching.length||void 0!==r&&!h.trimCharsBeforeMatching.includes(r))){n=t;break}}else if(t.startsWith("matchRight"))for(let t=i;t<e.length;t++){const r=e[t];if((!h.trimBeforeMatching||h.trimBeforeMatching&&r.trim())&&(!h.trimCharsBeforeMatching.length||!h.trimCharsBeforeMatching.includes(r))){n=t;break}}if(void 0===n)return!1;const o=e[n],a=n+1;let s="";return a&&a>0&&(s=e.slice(0,a)),"L"===t[5]?h.cb(o,s,n):(n&&n>0&&(s=e.slice(n)),h.cb(o,s,n))}let n="";throw c||(n=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${t}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${n}`)}for(let n=0,i=l.length;n<i;n++){f="function"==typeof l[n];const i=l[n];let o,s,c="",u=r;"matchRight"===t?u+=1:"matchLeft"===t&&(u-=1);const g=a(e,u,i,h,f,e=>"L"===t[5]?e-1:e+1);if(g&&f&&"function"==typeof i&&"EOL"===i())return!(!i()||h.cb&&!h.cb(o,c,s))&&i();if(Number.isInteger(g)&&(s=t.startsWith("matchLeft")?g-1:g+1,c="L"===t[5]?e.slice(0,g):e.slice(s)),s<0&&(s=void 0),e[s]&&(o=e[s]),Number.isInteger(g)&&(!h.cb||h.cb(o,c,s)))return i}return!1}("matchRightIncl",t,e,r,s)}function c(t){return"string"==typeof t}return function(i,o,a,h){if(h&&(!(l=h)||"object"!==t(l)||Array.isArray(l)))throw new TypeError("string-find-heads-tails: [THROW_ID_01] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: ".concat(h," (type: ").concat(t(h),")"));var l,f,u,g={fromIndex:0,throwWhenSomethingWrongIsDetected:!0,allowWholeValueToBeOnlyHeadsOrTails:!0,source:"string-find-heads-tails",matchHeadsAndTailsStrictlyInPairsByTheirOrder:!1,relaxedAPI:!1},d=function(t){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?r(Object(i),!0).forEach((function(r){e(t,r,i[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}({},g,{},h);if("string"==typeof d.fromIndex&&/^\d*$/.test(d.fromIndex))d.fromIndex=Number(d.fromIndex);else if(!Number.isInteger(d.fromIndex)||d.fromIndex<0)throw new TypeError("".concat(d.source," [THROW_ID_18] the fourth input argument must be a natural number or zero! Currently it's: ").concat(d.fromIndex));if(!c(i)||0===i.length){if(d.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_02] the first input argument, input string, must be a non-zero-length string! Currently it's: ".concat(t(i),", equal to: ").concat(i))}if("string"!=typeof o&&!Array.isArray(o)){if(d.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_03] the second input argument, heads, must be either a string or an array of strings! Currently it's: ".concat(t(o),", equal to:\n").concat(JSON.stringify(o,null,4)))}if("string"==typeof o){if(0===o.length){if(d.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_04] the second input argument, heads, must be a non-empty string! Currently it's empty.")}o=n(o)}else if(Array.isArray(o)){if(0===o.length){if(d.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_05] the second input argument, heads, must be a non-empty array and contain at least one string! Currently it's empty.")}if(o.every((function(t,e){return f=t,u=e,c(t)}))){if(!o.every((function(t,e){return u=e,c(t)&&t.length>0&&""!==t.trim()}))){if(!d.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_07] the second input argument, heads, should not contain empty strings! For example, there's one detected at index ".concat(u," of heads array:\n").concat(JSON.stringify(o,null,4),"."));if(0===(o=o.filter((function(t){return c(t)&&t.length>0}))).length)return[]}}else{if(!d.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_06] the second input argument, heads, contains non-string elements! For example, element at ".concat(u,"th index is ").concat(t(f),", equal to:\n").concat(JSON.stringify(f,null,4),". Whole heads array looks like:\n").concat(JSON.stringify(o,null,4)));if(0===(o=o.filter((function(t){return c(t)&&t.length>0}))).length)return[]}}if(!c(a)&&!Array.isArray(a)){if(d.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_08] the third input argument, tails, must be either a string or an array of strings! Currently it's: ".concat(t(a),", equal to:\n").concat(JSON.stringify(a,null,4)))}if(c(a)){if(0===a.length){if(d.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_09] the third input argument, tails, must be a non-empty string! Currently it's empty.")}a=n(a)}else if(Array.isArray(a)){if(0===a.length){if(d.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_10] the third input argument, tails, must be a non-empty array and contain at least one string! Currently it's empty.")}if(a.every((function(t,e){return f=t,u=e,c(t)}))){if(!a.every((function(t,e){return u=e,c(t)&&t.length>0&&""!==t.trim()}))){if(!d.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_12] the third input argument, tails, should not contain empty strings! For example, there's one detected at index ".concat(u,". Whole tails array is equal to:\n").concat(JSON.stringify(a,null,4)));if(0===(a=a.filter((function(t){return c(t)&&t.length>0}))).length)return[]}}else{if(!d.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_11] the third input argument, tails, contains non-string elements! For example, element at ".concat(u,"th index is ").concat(t(f),", equal to:\n").concat(JSON.stringify(f,null,4),". Whole tails array is equal to:\n").concat(JSON.stringify(a,null,4)));if(0===(a=a.filter((function(t){return c(t)&&t.length>0}))).length)return[]}}var m=d.source===g.source;if(d.throwWhenSomethingWrongIsDetected&&!d.allowWholeValueToBeOnlyHeadsOrTails){if(n(o).includes(i))throw new Error("".concat(d.source).concat(m?": [THROW_ID_16]":""," the whole input string can't be equal to ").concat(c(o)?"":"one of ","heads (").concat(i,")!"));if(n(a).includes(i))throw new Error("".concat(d.source).concat(m?": [THROW_ID_17]":""," the whole input string can't be equal to ").concat(c(a)?"":"one of ","tails (").concat(i,")!"))}for(var y,p=o.concat(a).map((function(t){return t.charAt(0)})).reduce((function(t,e){return e.charCodeAt(0)>t[1]?[t[0],e.charCodeAt(0)]:e.charCodeAt(0)<t[0]?[e.charCodeAt(0),t[1]]:t}),[o[0].charCodeAt(0),o[0].charCodeAt(0)]),w=[],b=!1,O={},I=!1,T=d.fromIndex,A=i.length;T<A;T++){var W=i[T].charCodeAt(0);if(W<=p[1]&&W>=p[0]){var _=s(i,T,o);if(_&&d.matchHeadsAndTailsStrictlyInPairsByTheirOrder)for(var M=o.length;M--;)if(o[M]===_){y=M;break}if(_){if(!b){(O={}).headsStartAt=T,O.headsEndAt=T+_.length,b=!0,T+=_.length-1,I&&(I=!1);continue}if(d.throwWhenSomethingWrongIsDetected)throw new TypeError("".concat(d.source).concat(m?": [THROW_ID_19]":"",' When processing "').concat(i,'", we found heads (').concat(i.slice(T,T+_.length),') starting at character with index number "').concat(T,'" and there was another set of heads before it! Generally speaking, there should be "heads-tails-heads-tails", not "heads-heads-tails"!\nWe\'re talking about the area of the code:\n\n\n--------------------------------------starts\n').concat(i.slice(Math.max(T-200,0),T),"\n      ","[".concat(33,"m-------\x3e[",39,"m")," ","[".concat(31,"m",i.slice(T,T+_.length),"[",39,"m")," [",33,"m","<-------","[",39,"m\n").concat(i.slice(T+_.length,Math.min(A,T+200)),"\n--------------------------------------ends\n\n\nTo turn off this error being thrown, set opts.throwWhenSomethingWrongIsDetected to Boolean false."))}var x=s(i,T,a);if(b&&x&&d.matchHeadsAndTailsStrictlyInPairsByTheirOrder&&void 0!==y&&void 0!==a[y]&&a[y]!==x){for(var C=void 0,D=a.length;D--;)if(a[D]===x){C=D;break}throw new TypeError("".concat(d.source).concat(m?": [THROW_ID_20]":"",' When processing "').concat(i,'", we had "opts.matchHeadsAndTailsStrictlyInPairsByTheirOrder" on. We found heads (').concat(o[y],") but the tails the followed it were not of the same index, ").concat(y," (").concat(a[y],") but ").concat(C," (").concat(x,")."))}if(x){if(b){O.tailsStartAt=T,O.tailsEndAt=T+x.length,w.push(O),O={},b=!1,T+=x.length-1;continue}d.throwWhenSomethingWrongIsDetected&&(I="".concat(d.source).concat(m?": [THROW_ID_21]":"",' When processing "').concat(i,'", we found tails (').concat(i.slice(T,T+x.length),') starting at character with index number "').concat(T,"\" but there were no heads preceding it. That's very naughty!"))}}if(d.throwWhenSomethingWrongIsDetected&&T===A-1){if(0!==Object.keys(O).length)throw new TypeError("".concat(d.source).concat(m?": [THROW_ID_22]":"",' When processing "').concat(i,"\", we reached the end of the string and yet didn't find any tails (").concat(JSON.stringify(a,null,4),") to match the last detected heads (").concat(i.slice(O.headsStartAt,O.headsEndAt),")!"));if(I)throw new Error(I)}}return w}}));
