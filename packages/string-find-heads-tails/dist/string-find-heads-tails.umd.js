/**
 * string-find-heads-tails
 * Search for string pairs. A special case of string search algorithm.
 * Version: 3.15.8
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-find-heads-tails
 */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).stringFindHeadsTails=e()}(this,(function(){"use strict";function t(e){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(e)}
/*!
   * is-natural-number-string | MIT (c) Shinnosuke Watanabe
   * https://github.com/shinnn/is-natural-number-string
  */var e=function(t,e){if("string"!=typeof t)return!1;if(e&&"includeZero"in e){if("boolean"!=typeof e.includeZero)throw new TypeError(String(e.includeZero)+" is neither true nor false. `includeZero` option must be a Boolean value.");if(e.includeZero)return/^(-?0|[1-9]\d*)(\.0+)?$/.test(t)}return/^[1-9]\d*(\.0+)?$/.test(t)},n=function(t,e){if(e){if("object"!=typeof e)throw new TypeError(String(e)+" is not an object. Expected an object that has boolean `includeZero` property.");if("includeZero"in e){if("boolean"!=typeof e.includeZero)throw new TypeError(String(e.includeZero)+" is neither true nor false. `includeZero` option must be a Boolean value.");if(e.includeZero&&0===t)return!0}}return Number.isSafeInteger(t)&&t>=1},r="[object Object]";
/*!
   * is-natural-number.js | MIT (c) Shinnosuke Watanabe
   * https://github.com/shinnn/is-natural-number.js
  */var i,o,a=Function.prototype,c=Object.prototype,s=a.toString,l=c.hasOwnProperty,h=s.call(Object),f=c.toString,u=(i=Object.getPrototypeOf,o=Object,function(t){return i(o(t))});var g=function(t){if(!function(t){return!!t&&"object"==typeof t}(t)||f.call(t)!=r||function(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}(t))return!1;var e=u(t);if(null===e)return!0;var n=l.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&s.call(n)==h},d="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},m="[object AsyncFunction]",y="[object Function]",p="[object GeneratorFunction]",w="[object Null]",b="[object Proxy]",O="[object Undefined]",T="object"==typeof d&&d&&d.Object===Object&&d,I="object"==typeof self&&self&&self.Object===Object&&self,_=T||I||Function("return this")(),W=Object.prototype,C=W.hasOwnProperty,x=W.toString,A=_.Symbol,E=A?A.toStringTag:void 0;function v(t){return null==t?void 0===t?O:w:E&&E in Object(t)?function(t){var e=C.call(t,E),n=t[E];try{t[E]=void 0;var r=!0}catch(t){}var i=x.call(t);r&&(e?t[E]=n:delete t[E]);return i}(t):function(t){return x.call(t)}(t)}var S=function(t){if(!function(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)}(t))return!1;var e=v(t);return e==y||e==p||e==m||e==b};function H(t){return"string"==typeof t?t.length>0?[t]:[]:t}function j(t){if("string"==typeof t)return 0!==t.length&&(t.charCodeAt(0)>=55296&&t.charCodeAt(0)<=56319);if(void 0===t)return!1;throw new TypeError(`string-character-is-astral-surrogate/isHighSurrogate(): the input is not string but ${typeof t}`)}function B(t){if("string"==typeof t)return 0!==t.length&&(t.charCodeAt(0)>=56320&&t.charCodeAt(0)<=57343);if(void 0===t)return!1;throw new TypeError(`string-character-is-astral-surrogate/isLowSurrogate(): the input is not string but ${typeof t}`)}const D=Array.isArray;function R(t){return null!=t}function M(t){return"string"==typeof t}function $(t){return"string"==typeof t&&(t.charCodeAt(0)>=55296&&t.charCodeAt(0)<=57343)}function P(t,e,n,r,i){const o="function"==typeof n?n():n;if(e>=t.length&&i&&"EOL"===o)return o;if(!(e<=t.length)){if(r.relaxedApi)return!1;throw new Error(`string-match-left-right/marchForward(): [THROW_ID_102] second argument, fromIndexInclusive is ${e} beyond the input string length, ${t.length}.`)}{let a=i?1:n.length;for(let i=e,o=t.length;i<o;i++){let e=t[i];if(j(t[i])&&B(t[i+1])&&(e=t[i]+t[i+1]),B(t[i])&&j(t[i-1])&&(e=t[i-1]+t[i]),r.trimBeforeMatching&&""===t[i].trim())continue;if(!r.i&&r.trimCharsBeforeMatching.includes(e)||r.i&&r.trimCharsBeforeMatching.map(t=>t.toLowerCase()).includes(e.toLowerCase())){2===e.length&&(i+=1);continue}let o=n[n.length-a];if(j(o)&&R(n[n.length-a+1])&&B(n[n.length-a+1])&&(o=n[n.length-a]+n[n.length-a+1]),!(!r.i&&e===o||r.i&&e.toLowerCase()===o.toLowerCase()))return!1;if(a-=e.length,a<1){let r=i-n.length+e.length;return r>=0&&B(t[r])&&R(t[r-1])&&j(t[r-1])&&(r-=1),r>=0?r:0}2===e.length&&j(t[i])&&(i+=1)}if(a>0)return!(!i||"EOL"!==o)}}function L(t,e,n,r,i){const o="function"==typeof n?n():n;if(e<0&&i&&"EOL"===o)return o;if(e>=t.length){if(r.relaxedApi)return!1;throw new Error(`string-match-left-right/marchBackward(): [THROW_ID_203] second argument, starting index, should not be beyond the last character of the input string! Currently the first argument's last character's index is ${t.length} but the second argument is beyond it:\n${JSON.stringify(e,null,4)}`)}let a=i?1:n.length;for(let o=e+1;o--;){if(r.trimBeforeMatching&&""===t[o].trim()){if(0===o&&i&&"EOL"===n)return!0;continue}let e=t[o];if(B(t[o])&&j(t[o-1])?e=t[o-1]+t[o]:j(t[o])&&B(t[o+1])&&(e=t[o]+t[o+1]),!r.i&&r.trimCharsBeforeMatching.includes(e)||r.i&&r.trimCharsBeforeMatching.map(t=>t.toLowerCase()).includes(e.toLowerCase())){if(2===e.length&&(o-=1),i&&"EOL"===n&&0===o)return!0;continue}let c=n[a-1];if(B(c)&&(c=`${n[a-2]}${n[a-1]}`,a-=1,o-=1),!(!r.i&&e===c||r.i&&e.toLowerCase()===c.toLowerCase()))return!1;if(a-=1,a<1)return o>=0?o:0}return a>0?!(!i||"EOL"!==o):void 0}function N(t,e,r,i){return function(t,e,r,i,o){if(g(o)&&Object.prototype.hasOwnProperty.call(o,"trimBeforeMatching")&&"boolean"!=typeof o.trimBeforeMatching)throw new Error(`string-match-left-right/${t}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${D(o.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);const a=Object.assign({},{i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],relaxedApi:!1},o);let c,s,l,h;if(a.trimCharsBeforeMatching=H(a.trimCharsBeforeMatching),a.trimCharsBeforeMatching=a.trimCharsBeforeMatching.map(t=>M(t)?t:String(t)),a.trimCharsBeforeMatching.some((t,e)=>t.length>1&&!$(t)&&(c=e,s=t,!0)))throw new Error(`string-match-left-right/${t}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${c} is longer than 1 character, ${s.length} (equals to ${s}). Please split it into separate characters and put into array as separate elements.`);if(!M(e)){if(a.relaxedApi)return!1;throw new Error(`string-match-left-right/${t}(): [THROW_ID_01] the first argument should be a string. Currently it's of a type: ${typeof e}, equal to:\n${JSON.stringify(e,null,4)}`)}if(0===e.length){if(a.relaxedApi)return!1;throw new Error(`string-match-left-right/${t}(): [THROW_ID_02] the first argument should be a non-empty string. Currently it's empty!`)}if(!n(r,{includeZero:!0})){if(a.relaxedApi)return!1;throw new Error(`string-match-left-right/${t}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof r}, equal to:\n${JSON.stringify(r,null,4)}`)}if(M(i))l=[i];else if(D(i))l=i;else if(R(i)){if(!S(i))throw new Error(`string-match-left-right/${t}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof i}, equal to:\n${JSON.stringify(i,null,4)}`);l=[],l.push(i)}else l=i;if(R(o)&&!g(o))throw new Error(`string-match-left-right/${t}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof o}", and equal to:\n${JSON.stringify(o,null,4)}`);if(!R(l)||!D(l)||D(l)&&!l.length||D(l)&&1===l.length&&M(l[0])&&0===l[0].trim().length){if("function"==typeof a.cb){let n,i=r;if("matchRight"===t&&j(e[r])&&B(e[r+1])&&(i+=1),"matchLeftIncl"!==t&&"matchRight"!==t||(i+=1),t.startsWith("matchLeft"))for(let t=i;t--;){if(B(e[t])&&j(e[t-1]))continue;let r=e[t];if(j(e[t])&&B(e[t+1])&&(r=e[t]+e[t+1]),(!a.trimBeforeMatching||a.trimBeforeMatching&&void 0!==r&&""!==r.trim())&&(0===a.trimCharsBeforeMatching.length||void 0!==r&&!a.trimCharsBeforeMatching.includes(r))){n=t;break}B(e[t-1])&&j(e[t-2])&&(t-=1)}else if(t.startsWith("matchRight"))for(let t=i;t<e.length;t++){let r=e[t];if(j(e[t])&&B(e[t+1])&&(r=e[t]+e[t+1]),(!a.trimBeforeMatching||a.trimBeforeMatching&&""!==r.trim())&&(0===a.trimCharsBeforeMatching.length||!a.trimCharsBeforeMatching.includes(r))){n=t;break}j(e[t])&&B(e[t+1])&&(t+=1)}if(void 0===n)return!1;let o=e[n];j(e[n])&&B(e[n+1])&&(o=e[n]+e[n+1]),B(e[n])&&j(e[n-1])&&(o=e[n-1]+e[n],n-=1);let c,s=n+1;return j(e[n])&&B(e[n+1])&&(s+=1),s&&s>0&&(c=e.slice(0,s)),t.startsWith("matchLeft")?a.cb(o,c,n):(n&&n>0&&(c=e.slice(n)),a.cb(o,c,n))}let n="";throw R(o)||(n=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${t}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${n}`)}if(t.startsWith("matchLeft")){for(let n=0,i=l.length;n<i;n++){h="function"==typeof l[n];const i=l[n];let o,c,s="",f=r;"matchLeft"===t&&($(e[n-1])&&$(e[n-2])?f-=2:f-=1);const u=L(e,f,i,a,h);if(u&&h&&"function"==typeof i&&"EOL"===i())return!(!i()||a.cb&&!a.cb(o,s,c))&&i();if(R(u)&&u>0&&(c=u-1,o=e[c],s=e.slice(0,u)),B(e[c])&&R(e[c-1])&&j(e[c-1])&&(c-=1,o=e[c-1]+e[c]),j(e[c])&&R(e[c+1])&&B(e[c+1])&&(o=e[c]+e[c+1],s=e.slice(0,c+2)),!1!==u&&(!a.cb||a.cb(o,s,c)))return i}return!1}for(let n=0,i=l.length;n<i;n++){h="function"==typeof l[n];const i=l[n];let o=r+("matchRight"===t?1:0);"matchRight"===t&&j(e[o-1])&&B(e[o])&&(o+=1);const c=P(e,o,i,a,h);if(c&&h&&"function"==typeof i&&"EOL"===i()){let t,e,n;return!(!i()||a.cb&&!a.cb(t,e,n))&&i()}let s,f,u;if(R(c)&&R(e[c+i.length-1])&&(s=c+i.length,f=e[s],j(e[s])&&B(e[s+1])&&(f=e[s]+e[s+1])),R(s)&&s>=0&&(u=e.slice(s)),!1!==c&&(!a.cb||a.cb(f,u,s)))return i}return!1}("matchRightIncl",t,e,r,i)}function q(t){return"string"==typeof t}var J=Array.isArray;function Z(t){throw new Error("string-find-heads-tails: [THROW_ID_01*] Missing ".concat(t,"th parameter!"))}return function(n,r,i,o){if(null!=o){if("object"!==t(o))throw new TypeError("string-find-heads-tails: [THROW_ID_13] the fourth input argument, Optional Options Object, must be a plain object! Currently it's: ".concat(t(o),", equal to: ").concat(o));e(o.fromIndex,{includeZero:!0})&&(o.fromIndex=Number(o.fromIndex))}var a,c,s={fromIndex:0,throwWhenSomethingWrongIsDetected:!0,allowWholeValueToBeOnlyHeadsOrTails:!0,source:"string-find-heads-tails",matchHeadsAndTailsStrictlyInPairsByTheirOrder:!1,relaxedAPI:!1};if((o=Object.assign({},s,o)).relaxedAPI||(void 0===n&&Z(1),void 0===r&&Z(2),void 0===i&&Z(3)),!q(n)||0===n.length){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_02] the first input argument, input string, must be a non-zero-length string! Currently it's: ".concat(t(n),", equal to: ").concat(n))}if(!q(r)&&!J(r)){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_03] the second input argument, heads, must be either a string or an array of strings! Currently it's: ".concat(t(r),", equal to:\n").concat(JSON.stringify(r,null,4)))}if(q(r)){if(0===r.length){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_04] the second input argument, heads, must be a non-empty string! Currently it's empty.")}r=H(r)}else if(J(r)){if(0===r.length){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_05] the second input argument, heads, must be a non-empty array and contain at least one string! Currently it's empty.")}if(r.every((function(t,e){return a=t,c=e,q(t)}))){if(!r.every((function(t,e){return c=e,q(t)&&t.length>0&&""!==t.trim()}))){if(!o.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_07] the second input argument, heads, should not contain empty strings! For example, there's one detected at index ".concat(c," of heads array:\n").concat(JSON.stringify(r,null,4),"."));if(0===(r=r.filter((function(t){return q(t)&&t.length>0}))).length)return[]}}else{if(!o.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_06] the second input argument, heads, contains non-string elements! For example, element at ".concat(c,"th index is ").concat(t(a),", equal to:\n").concat(JSON.stringify(a,null,4),". Whole heads array looks like:\n").concat(JSON.stringify(r,null,4)));if(0===(r=r.filter((function(t){return q(t)&&t.length>0}))).length)return[]}}if(!q(i)&&!J(i)){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_08] the third input argument, tails, must be either a string or an array of strings! Currently it's: ".concat(t(i),", equal to:\n").concat(JSON.stringify(i,null,4)))}if(q(i)){if(0===i.length){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_09] the third input argument, tails, must be a non-empty string! Currently it's empty.")}i=H(i)}else if(J(i)){if(0===i.length){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_10] the third input argument, tails, must be a non-empty array and contain at least one string! Currently it's empty.")}if(i.every((function(t,e){return a=t,c=e,q(t)}))){if(!i.every((function(t,e){return c=e,q(t)&&t.length>0&&""!==t.trim()}))){if(!o.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_12] the third input argument, tails, should not contain empty strings! For example, there's one detected at index ".concat(c,". Whole tails array is equal to:\n").concat(JSON.stringify(i,null,4)));if(0===(i=i.filter((function(t){return q(t)&&t.length>0}))).length)return[]}}else{if(!o.relaxedAPI)throw new TypeError("string-find-heads-tails: [THROW_ID_11] the third input argument, tails, contains non-string elements! For example, element at ".concat(c,"th index is ").concat(t(a),", equal to:\n").concat(JSON.stringify(a,null,4),". Whole tails array is equal to:\n").concat(JSON.stringify(i,null,4)));if(0===(i=i.filter((function(t){return q(t)&&t.length>0}))).length)return[]}}var l=o.source===s.source;if(o.throwWhenSomethingWrongIsDetected&&!o.allowWholeValueToBeOnlyHeadsOrTails){if(H(r).includes(n))throw new Error("".concat(o.source).concat(l?": [THROW_ID_16]":""," the whole input string can't be equal to ").concat(q(r)?"":"one of ","heads (").concat(n,")!"));if(H(i).includes(n))throw new Error("".concat(o.source).concat(l?": [THROW_ID_17]":""," the whole input string can't be equal to ").concat(q(i)?"":"one of ","tails (").concat(n,")!"))}if(!(Number.isInteger(o.fromIndex)&&o.fromIndex>=0||e(o.fromIndex,{includeZero:!0})))throw new TypeError("".concat(o.source).concat(l?": [THROW_ID_18]":""," the fourth input argument must be a natural number! Currently it's: ").concat(o.fromIndex));for(var h,f=r.concat(i).map((function(t){return t.charAt(0)})).reduce((function(t,e){return e.charCodeAt(0)>t[1]?[t[0],e.charCodeAt(0)]:e.charCodeAt(0)<t[0]?[e.charCodeAt(0),t[1]]:t}),[r[0].charCodeAt(0),r[0].charCodeAt(0)]),u=[],g=!1,d={},m=!1,y=o.fromIndex,p=n.length;y<p;y++){var w=n[y].charCodeAt(0);if(w<=f[1]&&w>=f[0]){var b=N(n,y,r);if(b&&o.matchHeadsAndTailsStrictlyInPairsByTheirOrder)for(var O=r.length;O--;)if(r[O]===b){h=O;break}if(b){if(!g){(d={}).headsStartAt=y,d.headsEndAt=y+b.length,g=!0,y+=b.length-1,m&&(m=!1);continue}if(o.throwWhenSomethingWrongIsDetected)throw new TypeError("".concat(o.source).concat(l?": [THROW_ID_19]":"",' When processing "').concat(n,'", we found heads (').concat(n.slice(y,y+b.length),') starting at character with index number "').concat(y,'" and there was another set of heads before it! Generally speaking, there should be "heads-tails-heads-tails", not "heads-heads-tails"!\nWe\'re talking about the area of the code:\n\n\n--------------------------------------starts\n').concat(n.slice(Math.max(y-200,0),y),"\n      ","[".concat(33,"m-------\x3e[",39,"m")," ","[".concat(31,"m",n.slice(y,y+b.length),"[",39,"m")," [",33,"m","<-------","[",39,"m\n").concat(n.slice(y+b.length,Math.min(p,y+200)),"\n--------------------------------------ends\n\n\nTo turn off this error being thrown, set opts.throwWhenSomethingWrongIsDetected to Boolean false."))}var T=N(n,y,i);if(g&&T&&o.matchHeadsAndTailsStrictlyInPairsByTheirOrder&&void 0!==h&&void 0!==i[h]&&i[h]!==T){for(var I=void 0,_=i.length;_--;)if(i[_]===T){I=_;break}throw new TypeError("".concat(o.source).concat(l?": [THROW_ID_20]":"",' When processing "').concat(n,'", we had "opts.matchHeadsAndTailsStrictlyInPairsByTheirOrder" on. We found heads (').concat(r[h],") but the tails the followed it were not of the same index, ").concat(h," (").concat(i[h],") but ").concat(I," (").concat(T,")."))}if(T){if(g){d.tailsStartAt=y,d.tailsEndAt=y+T.length,u.push(d),d={},g=!1,y+=T.length-1;continue}o.throwWhenSomethingWrongIsDetected&&(m="".concat(o.source).concat(l?": [THROW_ID_21]":"",' When processing "').concat(n,'", we found tails (').concat(n.slice(y,y+T.length),') starting at character with index number "').concat(y,"\" but there were no heads preceding it. That's very naughty!"))}}if(o.throwWhenSomethingWrongIsDetected&&y===p-1){if(0!==Object.keys(d).length)throw new TypeError("".concat(o.source).concat(l?": [THROW_ID_22]":"",' When processing "').concat(n,"\", we reached the end of the string and yet didn't find any tails (").concat(JSON.stringify(i,null,4),") to match the last detected heads (").concat(n.slice(d.headsStartAt,d.headsEndAt),")!"));if(m)throw new Error(m)}}return u}}));
