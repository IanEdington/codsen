/**
 * ranges-invert
 * Invert string index ranges [ [1, 3] ] => [ [0, 1], [3, ...] ]
 * Version: 2.1.33
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/ranges-invert
 */

!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(e=e||self).rangesInvert=r()}(this,(function(){"use strict";function e(r){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(r)}function r(e,r){if(!Array.isArray(e))throw new TypeError(`ranges-sort: [THROW_ID_01] Input must be an array, consisting of range arrays! Currently its type is: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(0===e.length)return e;const n=Object.assign({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null},r);let t,s;if(n.strictlyTwoElementsInRangeArrays&&!e.every((e,r)=>2===e.length||(t=r,s=e.length,!1)))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${t}th range (${JSON.stringify(e[t],null,4)}) has not two but ${s} elements!`);if(!e.every((e,r)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(t=r,!1)))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${t}th range (${JSON.stringify(e[t],null,4)}) does not consist of only natural numbers!`);const o=e.length*e.length;let i=0;return Array.from(e).sort((e,r)=>(n.progressFn&&(i++,n.progressFn(Math.floor(100*i/o))),e[0]===r[0]?e[1]<r[1]?-1:e[1]>r[1]?1:0:e[0]<r[0]?-1:1))}function n(e,n){function t(e){return"string"==typeof e}function s(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e))return e;const o={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};let i;if(n){if(!s(n))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(n,null,4)} (type ${typeof n})`);if(i=Object.assign({},o,n),i.progressFn&&s(i.progressFn)&&!Object.keys(i.progressFn).length)i.progressFn=null;else if(i.progressFn&&"function"!=typeof i.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof i.progressFn}", equal to ${JSON.stringify(i.progressFn,null,4)}`);if(i.mergeType&&1!==i.mergeType&&2!==i.mergeType)if(t(i.mergeType)&&"1"===i.mergeType.trim())i.mergeType=1;else{if(!t(i.mergeType)||"2"!==i.mergeType.trim())throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof i.mergeType}", equal to ${JSON.stringify(i.mergeType,null,4)}`);i.mergeType=2}if("boolean"!=typeof i.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof i.joinRangesThatTouchEdges}", equal to ${JSON.stringify(i.joinRangesThatTouchEdges,null,4)}`)}else i=Object.assign({},o);const a=e.map(e=>[...e]).filter(e=>void 0!==e[2]||e[0]!==e[1]);let g,u,l;g=i.progressFn?r(a,{progressFn:e=>{l=Math.floor(e/5),l!==u&&(u=l,i.progressFn(l))}}):r(a);const y=g.length-1;for(let e=y;e>0;e--)i.progressFn&&(l=Math.floor(78*(1-e/y))+21,l!==u&&l>u&&(u=l,i.progressFn(l))),(g[e][0]<=g[e-1][0]||!i.joinRangesThatTouchEdges&&g[e][0]<g[e-1][1]||i.joinRangesThatTouchEdges&&g[e][0]<=g[e-1][1])&&(g[e-1][0]=Math.min(g[e][0],g[e-1][0]),g[e-1][1]=Math.max(g[e][1],g[e-1][1]),void 0!==g[e][2]&&(g[e-1][0]>=g[e][0]||g[e-1][1]<=g[e][1])&&null!==g[e-1][2]&&(null===g[e][2]&&null!==g[e-1][2]?g[e-1][2]=null:void 0!==g[e-1][2]?2===i.mergeType&&g[e-1][0]===g[e][0]?g[e-1][2]=g[e][2]:g[e-1][2]+=g[e][2]:g[e-1][2]=g[e][2]),g.splice(e,1),e=g.length);return g}const t=Array.isArray;var s=Array.isArray;return function(r,o,i){if(!s(r)&&null!==r)throw new TypeError("ranges-invert: [THROW_ID_01] Input's first argument must be an array, consisting of range arrays! Currently its type is: ".concat(e(r),", equal to: ").concat(JSON.stringify(r,null,4)));if(!Number.isInteger(o)||o<0)throw new TypeError("ranges-invert: [THROW_ID_02] Input's second argument must be a natural number or zero (coming from String.length)! Currently its type is: ".concat(e(o),", equal to: ").concat(JSON.stringify(o,null,4)));if(null===r)return 0===o?[]:[[0,o]];if(0===r.length)return[];var a,g,u,l=Object.assign({},{strictlyTwoElementsInRangeArrays:!1,skipChecks:!1},i);if(!l.skipChecks&&l.strictlyTwoElementsInRangeArrays&&!r.every((function(e,r){return 2===e.length||(a=r,g=e.length,!1)})))throw new TypeError("ranges-invert: [THROW_ID_04] Because opts.strictlyTwoElementsInRangeArrays was enabled, all ranges must be strictly two-element-long. However, the ".concat(a,"th range (").concat(JSON.stringify(r[a],null,0),") has not two but ").concat(g," elements!"));if(!l.skipChecks&&!r.every((function(e,r){return!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(a=r,!1)}))){if(Array.isArray(r)&&"number"==typeof r[0]&&"number"==typeof r[1])throw new TypeError("ranges-invert: [THROW_ID_07] The first argument should be AN ARRAY OF RANGES, not a single range! Currently arrOfRanges = ".concat(JSON.stringify(r,null,0),"!"));throw new TypeError("ranges-invert: [THROW_ID_05] The first argument should be AN ARRAY OF ARRAYS! Each sub-array means string slice indexes. In our case, here ".concat(a+1,"th range (").concat(JSON.stringify(r[a],null,0),") does not consist of only natural numbers!"))}return 0===(u=l.skipChecks?r.filter((function(e){return e[0]!==e[1]})):n(r.filter((function(e){return e[0]!==e[1]})))).length?0===o?[]:[[0,o]]:function(e,r){if(!t(e))throw new TypeError(`ranges-crop: [THROW_ID_01] The first input's argument must be an array, consisting of range arrays! Currently its type is: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(!Number.isInteger(r))throw new TypeError(`ranges-crop: [THROW_ID_02] The second input's argument must be a natural number or zero (coming from String.length)! Currently its type is: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);if(0===e.length)return e;let s;if(!e.every((e,r)=>!(!Number.isInteger(e[0])||!Number.isInteger(e[1]))||(s=r,!1))){if(Array.isArray(e)&&"number"==typeof e[0]&&"number"==typeof e[1])throw new TypeError(`ranges-crop: [THROW_ID_03] The first argument should be AN ARRAY OF RANGES, not a single range! Currently arrOfRanges = ${JSON.stringify(e,null,0)}!`);throw new TypeError(`ranges-crop: [THROW_ID_04] The first argument should be AN ARRAY OF ARRAYS! Each sub-array means string slice indexes. In our case, here ${s+1}th range (${JSON.stringify(e[s],null,0)}) does not consist of only natural numbers!`)}if(!e.every((e,r)=>null==e[2]||"string"==typeof e[2]||(s=r,!1)))throw new TypeError(`ranges-crop: [THROW_ID_05] The third argument, if present at all, should be of a string-type or null. Currently the ${s}th range ${JSON.stringify(e[s],null,0)} has a argument in the range of a type ${typeof e[s][2]}`);return n(e).filter(e=>e[0]<=r&&(void 0!==e[2]||e[0]<r)).map(e=>e[1]>r?void 0!==e[2]?[e[0],r,e[2]]:[e[0],r]:e)}(u.reduce((function(e,r,n,t){var s=[];0===n&&0!==t[0][0]&&s.push([0,t[0][0]]);var i=n<t.length-1?t[n+1][0]:o;if(r[1]!==i){if(l.skipChecks&&r[1]>i)throw new TypeError("ranges-invert: [THROW_ID_08] The checking (opts.skipChecks) is off and input ranges were not sorted! We nearly wrote range [".concat(r[1],", ").concat(i,"] which is backwards. For investigation, whole ranges array is:\n").concat(JSON.stringify(t,null,0)));s.push([r[1],i])}return e.concat(s)}),[]),o)}}));
