/**
 * array-group-str-omit-num-char
 * Groups array of strings by omitting number characters
 * Version: 2.1.40
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/array-group-str-omit-num-char
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).arrayGroupStrOmitNumChar=t()}(this,(function(){"use strict";function e(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function t(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function r(r){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?t(Object(o),!0).forEach((function(t){e(r,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(o)):t(Object(o)).forEach((function(e){Object.defineProperty(r,e,Object.getOwnPropertyDescriptor(o,e))}))}return r}var n="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},o=/^\[object .+?Constructor\]$/,a="object"==typeof n&&n&&n.Object===Object&&n,i="object"==typeof self&&self&&self.Object===Object&&self,s=a||i||Function("return this")();function u(e,t){return!!(e?e.length:0)&&function(e,t,r){if(t!=t)return function(e,t,r,n){var o=e.length,a=r+(n?1:-1);for(;n?a--:++a<o;)if(t(e[a],a,e))return a;return-1}(e,f,r);var n=r-1,o=e.length;for(;++n<o;)if(e[n]===t)return n;return-1}(e,t,0)>-1}function l(e,t,r){for(var n=-1,o=e?e.length:0;++n<o;)if(r(t,e[n]))return!0;return!1}function f(e){return e!=e}function c(e,t){return e.has(t)}function p(e){var t=-1,r=Array(e.size);return e.forEach((function(e){r[++t]=e})),r}var h,g=Array.prototype,y=Function.prototype,d=Object.prototype,_=s["__core-js_shared__"],m=(h=/[^.]+$/.exec(_&&_.keys&&_.keys.IE_PROTO||""))?"Symbol(src)_1."+h:"",w=y.toString,b=d.hasOwnProperty,v=d.toString,O=RegExp("^"+w.call(b).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),T=g.splice,W=C(s,"Map"),$=C(s,"Set"),j=C(Object,"create");function R(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function E(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function I(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function A(e){var t=-1,r=e?e.length:0;for(this.__data__=new I;++t<r;)this.add(e[t])}function F(e,t){for(var r,n,o=e.length;o--;)if((r=e[o][0])===(n=t)||r!=r&&n!=n)return o;return-1}function N(e){return!(!H(e)||(t=e,m&&m in t))&&(function(e){var t=H(e)?v.call(e):"";return"[object Function]"==t||"[object GeneratorFunction]"==t}(e)||function(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}(e)?O:o).test(function(e){if(null!=e){try{return w.call(e)}catch(e){}try{return e+""}catch(e){}}return""}(e));var t}R.prototype.clear=function(){this.__data__=j?j(null):{}},R.prototype.delete=function(e){return this.has(e)&&delete this.__data__[e]},R.prototype.get=function(e){var t=this.__data__;if(j){var r=t[e];return"__lodash_hash_undefined__"===r?void 0:r}return b.call(t,e)?t[e]:void 0},R.prototype.has=function(e){var t=this.__data__;return j?void 0!==t[e]:b.call(t,e)},R.prototype.set=function(e,t){return this.__data__[e]=j&&void 0===t?"__lodash_hash_undefined__":t,this},E.prototype.clear=function(){this.__data__=[]},E.prototype.delete=function(e){var t=this.__data__,r=F(t,e);return!(r<0)&&(r==t.length-1?t.pop():T.call(t,r,1),!0)},E.prototype.get=function(e){var t=this.__data__,r=F(t,e);return r<0?void 0:t[r][1]},E.prototype.has=function(e){return F(this.__data__,e)>-1},E.prototype.set=function(e,t){var r=this.__data__,n=F(r,e);return n<0?r.push([e,t]):r[n][1]=t,this},I.prototype.clear=function(){this.__data__={hash:new R,map:new(W||E),string:new R}},I.prototype.delete=function(e){return D(this,e).delete(e)},I.prototype.get=function(e){return D(this,e).get(e)},I.prototype.has=function(e){return D(this,e).has(e)},I.prototype.set=function(e,t){return D(this,e).set(e,t),this},A.prototype.add=A.prototype.push=function(e){return this.__data__.set(e,"__lodash_hash_undefined__"),this},A.prototype.has=function(e){return this.__data__.has(e)};var S=$&&1/p(new $([,-0]))[1]==1/0?function(e){return new $(e)}:function(){};function D(e,t){var r,n,o=e.__data__;return("string"==(n=typeof(r=t))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==r:null===r)?o["string"==typeof t?"string":"hash"]:o.map}function C(e,t){var r=function(e,t){return null==e?void 0:e[t]}(e,t);return N(r)?r:void 0}function H(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}var P=function(e){return e&&e.length?function(e,t,r){var n=-1,o=u,a=e.length,i=!0,s=[],f=s;if(r)i=!1,o=l;else if(a>=200){var h=t?null:S(e);if(h)return p(h);i=!1,o=c,f=new A}else f=t?[]:s;e:for(;++n<a;){var g=e[n],y=t?t(g):g;if(g=r||0!==g?g:0,i&&y==y){for(var d=f.length;d--;)if(f[d]===y)continue e;t&&f.push(y),s.push(g)}else o(f,y,r)||(f!==s&&f.push(y),s.push(g))}return s}(e):[]};function J(e,t){if(!Array.isArray(e)||!e.length)return e;const r={strictlyTwoElementsInRangeArrays:!1,progressFn:null,...t};let n,o;if(r.strictlyTwoElementsInRangeArrays&&!e.every((e,t)=>2===e.length||(n=t,o=e.length,!1)))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) has not two but ${o} elements!`);if(!e.every((e,t)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(n=t,!1)))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) does not consist of only natural numbers!`);const a=e.length*e.length;let i=0;return Array.from(e).sort((e,t)=>(r.progressFn&&(i+=1,r.progressFn(Math.floor(100*i/a))),e[0]===t[0]?e[1]<t[1]?-1:e[1]>t[1]?1:0:e[0]<t[0]?-1:1))}function x(e,t){function r(e){return"string"==typeof e}function n(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e)||!e.length)return e;const o={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};let a;if(t){if(!n(t))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(t,null,4)} (type ${typeof t})`);if(a={...o,...t},a.progressFn&&n(a.progressFn)&&!Object.keys(a.progressFn).length)a.progressFn=null;else if(a.progressFn&&"function"!=typeof a.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof a.progressFn}", equal to ${JSON.stringify(a.progressFn,null,4)}`);if(a.mergeType&&1!==a.mergeType&&2!==a.mergeType)if(r(a.mergeType)&&"1"===a.mergeType.trim())a.mergeType=1;else{if(!r(a.mergeType)||"2"!==a.mergeType.trim())throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof a.mergeType}", equal to ${JSON.stringify(a.mergeType,null,4)}`);a.mergeType=2}if("boolean"!=typeof a.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof a.joinRangesThatTouchEdges}", equal to ${JSON.stringify(a.joinRangesThatTouchEdges,null,4)}`)}else a={...o};const i=e.map(e=>[...e]).filter(e=>void 0!==e[2]||e[0]!==e[1]);let s,u,l;s=a.progressFn?J(i,{progressFn:e=>{l=Math.floor(e/5),l!==u&&(u=l,a.progressFn(l))}}):J(i);const f=s.length-1;for(let e=f;e>0;e--)a.progressFn&&(l=Math.floor(78*(1-e/f))+21,l!==u&&l>u&&(u=l,a.progressFn(l))),(s[e][0]<=s[e-1][0]||!a.joinRangesThatTouchEdges&&s[e][0]<s[e-1][1]||a.joinRangesThatTouchEdges&&s[e][0]<=s[e-1][1])&&(s[e-1][0]=Math.min(s[e][0],s[e-1][0]),s[e-1][1]=Math.max(s[e][1],s[e-1][1]),void 0!==s[e][2]&&(s[e-1][0]>=s[e][0]||s[e-1][1]<=s[e][1])&&null!==s[e-1][2]&&(null===s[e][2]&&null!==s[e-1][2]?s[e-1][2]=null:void 0!==s[e-1][2]?2===a.mergeType&&s[e-1][0]===s[e][0]?s[e-1][2]=s[e][2]:s[e-1][2]+=s[e][2]:s[e-1][2]=s[e][2]),s.splice(e,1),e=s.length);return s}function M(e){return null!=e}function q(e){return"string"==typeof e}var k=Array.isArray;return function(e,t){if(!k(e))return e;if(!e.length)return{};var n,o,a={wildcard:"*",dedupePlease:!0};n=null!=t?r(r({},a),t):r({},a);for(var i=(o=n.dedupePlease?P(e):Array.from(e)).length,s={},u=0;u<i;u++){var l=o[u].match(/\d+/gm);l?function(){var e=o[u].replace(/\d+/gm,n.wildcard);Object.prototype.hasOwnProperty.call(s,e)?(l.forEach((function(t,r){s[e].elementsWhichWeCanReplaceWithWildcards[r]&&t!==s[e].elementsWhichWeCanReplaceWithWildcards[r]&&(s[e].elementsWhichWeCanReplaceWithWildcards[r]=!1)})),s[e].count+=1):s[e]={count:1,elementsWhichWeCanReplaceWithWildcards:Array.from(l)}}():s[o[u]]={count:1}}var f={};return Object.keys(s).forEach((function(e){var t=e;if(k(s[e].elementsWhichWeCanReplaceWithWildcards)&&s[e].elementsWhichWeCanReplaceWithWildcards.some((function(e){return!1!==e}))){for(var r=[],o=0,a=0;a<s[e].elementsWhichWeCanReplaceWithWildcards.length;a++)o=t.indexOf(n.wildcard,o+n.wildcard.length),!1!==s[e].elementsWhichWeCanReplaceWithWildcards[a]&&r.push([o,o+n.wildcard.length,s[e].elementsWhichWeCanReplaceWithWildcards[a]]);t=function(e,t,r){let n,o=0,a=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(!q(e))throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(null===t)return e;if(!Array.isArray(t))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(r&&"function"!=typeof r)throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);n=Array.isArray(t)&&(Number.isInteger(t[0])&&t[0]>=0||/^\d*$/.test(t[0]))&&(Number.isInteger(t[1])&&t[1]>=0||/^\d*$/.test(t[1]))?[Array.from(t)]:Array.from(t);const i=n.length;let s=0;n.forEach((e,t)=>{if(r&&(o=Math.floor(s/i*10),o!==a&&(a=o,r(o))),!Array.isArray(e))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${t}th element not an array: ${JSON.stringify(e,null,4)}, which is ${typeof e}`);if(!Number.isInteger(e[0])||e[0]<0){if(!/^\d*$/.test(e[0]))throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${t}th element, array [${e[0]},${e[1]}]. That array has first element not an integer, but ${typeof e[0]}, equal to: ${JSON.stringify(e[0],null,4)}. Computer doesn't like this.`);n[t][0]=Number.parseInt(n[t][0],10)}if(!Number.isInteger(e[1])){if(!/^\d*$/.test(e[1]))throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${t}th element, array [${e[0]},${e[1]}]. That array has second element not an integer, but ${typeof e[1]}, equal to: ${JSON.stringify(e[1],null,4)}. Computer doesn't like this.`);n[t][1]=Number.parseInt(n[t][1],10)}s+=1});const u=x(n,{progressFn:e=>{r&&(o=10+Math.floor(e/10),o!==a&&(a=o,r(o)))}}),l=u.length;if(l>0){const t=e.slice(u[l-1][1]);e=u.reduce((t,n,i,s)=>{r&&(o=20+Math.floor(i/l*80),o!==a&&(a=o,r(o)));const u=0===i?0:s[i-1][1],f=s[i][0];return t+e.slice(u,f)+(M(s[i][2])?s[i][2]:"")},""),e+=t}return e}(t,r)}f[t]=s[e].count})),f}}));
