/**
 * array-group-str-omit-num-char
 * Groups array of strings by omitting number characters
 * Version: 2.1.38
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/array-group-str-omit-num-char
 */

!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(e=e||self).arrayGroupStrOmitNumChar=r()}(this,(function(){"use strict";function e(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function r(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function t(t){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?r(Object(o),!0).forEach((function(r){e(t,r,o[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(o,e))}))}return t}var n="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},o=/^\[object .+?Constructor\]$/,a="object"==typeof n&&n&&n.Object===Object&&n,i="object"==typeof self&&self&&self.Object===Object&&self,s=a||i||Function("return this")();function u(e,r){return!!(e?e.length:0)&&function(e,r,t){if(r!=r)return function(e,r,t,n){var o=e.length,a=t+(n?1:-1);for(;n?a--:++a<o;)if(r(e[a],a,e))return a;return-1}(e,f,t);var n=t-1,o=e.length;for(;++n<o;)if(e[n]===r)return n;return-1}(e,r,0)>-1}function l(e,r,t){for(var n=-1,o=e?e.length:0;++n<o;)if(t(r,e[n]))return!0;return!1}function f(e){return e!=e}function c(e,r){return e.has(r)}function p(e){var r=-1,t=Array(e.size);return e.forEach((function(e){t[++r]=e})),t}var h,g=Array.prototype,y=Function.prototype,d=Object.prototype,_=s["__core-js_shared__"],m=(h=/[^.]+$/.exec(_&&_.keys&&_.keys.IE_PROTO||""))?"Symbol(src)_1."+h:"",w=y.toString,b=d.hasOwnProperty,v=d.toString,O=RegExp("^"+w.call(b).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),T=g.splice,W=C(s,"Map"),$=C(s,"Set"),j=C(Object,"create");function R(e){var r=-1,t=e?e.length:0;for(this.clear();++r<t;){var n=e[r];this.set(n[0],n[1])}}function E(e){var r=-1,t=e?e.length:0;for(this.clear();++r<t;){var n=e[r];this.set(n[0],n[1])}}function I(e){var r=-1,t=e?e.length:0;for(this.clear();++r<t;){var n=e[r];this.set(n[0],n[1])}}function A(e){var r=-1,t=e?e.length:0;for(this.__data__=new I;++r<t;)this.add(e[r])}function F(e,r){for(var t,n,o=e.length;o--;)if((t=e[o][0])===(n=r)||t!=t&&n!=n)return o;return-1}function N(e){return!(!H(e)||(r=e,m&&m in r))&&(function(e){var r=H(e)?v.call(e):"";return"[object Function]"==r||"[object GeneratorFunction]"==r}(e)||function(e){var r=!1;if(null!=e&&"function"!=typeof e.toString)try{r=!!(e+"")}catch(e){}return r}(e)?O:o).test(function(e){if(null!=e){try{return w.call(e)}catch(e){}try{return e+""}catch(e){}}return""}(e));var r}R.prototype.clear=function(){this.__data__=j?j(null):{}},R.prototype.delete=function(e){return this.has(e)&&delete this.__data__[e]},R.prototype.get=function(e){var r=this.__data__;if(j){var t=r[e];return"__lodash_hash_undefined__"===t?void 0:t}return b.call(r,e)?r[e]:void 0},R.prototype.has=function(e){var r=this.__data__;return j?void 0!==r[e]:b.call(r,e)},R.prototype.set=function(e,r){return this.__data__[e]=j&&void 0===r?"__lodash_hash_undefined__":r,this},E.prototype.clear=function(){this.__data__=[]},E.prototype.delete=function(e){var r=this.__data__,t=F(r,e);return!(t<0)&&(t==r.length-1?r.pop():T.call(r,t,1),!0)},E.prototype.get=function(e){var r=this.__data__,t=F(r,e);return t<0?void 0:r[t][1]},E.prototype.has=function(e){return F(this.__data__,e)>-1},E.prototype.set=function(e,r){var t=this.__data__,n=F(t,e);return n<0?t.push([e,r]):t[n][1]=r,this},I.prototype.clear=function(){this.__data__={hash:new R,map:new(W||E),string:new R}},I.prototype.delete=function(e){return D(this,e).delete(e)},I.prototype.get=function(e){return D(this,e).get(e)},I.prototype.has=function(e){return D(this,e).has(e)},I.prototype.set=function(e,r){return D(this,e).set(e,r),this},A.prototype.add=A.prototype.push=function(e){return this.__data__.set(e,"__lodash_hash_undefined__"),this},A.prototype.has=function(e){return this.__data__.has(e)};var S=$&&1/p(new $([,-0]))[1]==1/0?function(e){return new $(e)}:function(){};function D(e,r){var t,n,o=e.__data__;return("string"==(n=typeof(t=r))||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==t:null===t)?o["string"==typeof r?"string":"hash"]:o.map}function C(e,r){var t=function(e,r){return null==e?void 0:e[r]}(e,r);return N(t)?t:void 0}function H(e){var r=typeof e;return!!e&&("object"==r||"function"==r)}var P=function(e){return e&&e.length?function(e,r,t){var n=-1,o=u,a=e.length,i=!0,s=[],f=s;if(t)i=!1,o=l;else if(a>=200){var h=r?null:S(e);if(h)return p(h);i=!1,o=c,f=new A}else f=r?[]:s;e:for(;++n<a;){var g=e[n],y=r?r(g):g;if(g=t||0!==g?g:0,i&&y==y){for(var d=f.length;d--;)if(f[d]===y)continue e;r&&f.push(y),s.push(g)}else o(f,y,t)||(f!==s&&f.push(y),s.push(g))}return s}(e):[]};function J(e,r){if(!Array.isArray(e))throw new TypeError(`ranges-sort: [THROW_ID_01] Input must be an array, consisting of range arrays! Currently its type is: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(0===e.length)return e;const t={strictlyTwoElementsInRangeArrays:!1,progressFn:null,...r};let n,o;if(t.strictlyTwoElementsInRangeArrays&&!e.every((e,r)=>2===e.length||(n=r,o=e.length,!1)))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) has not two but ${o} elements!`);if(!e.every((e,r)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(n=r,!1)))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) does not consist of only natural numbers!`);const a=e.length*e.length;let i=0;return Array.from(e).sort((e,r)=>(t.progressFn&&(i+=1,t.progressFn(Math.floor(100*i/a))),e[0]===r[0]?e[1]<r[1]?-1:e[1]>r[1]?1:0:e[0]<r[0]?-1:1))}function x(e,r){function t(e){return"string"==typeof e}function n(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e))return e;const o={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};let a;if(r){if(!n(r))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(r,null,4)} (type ${typeof r})`);if(a={...o,...r},a.progressFn&&n(a.progressFn)&&!Object.keys(a.progressFn).length)a.progressFn=null;else if(a.progressFn&&"function"!=typeof a.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof a.progressFn}", equal to ${JSON.stringify(a.progressFn,null,4)}`);if(a.mergeType&&1!==a.mergeType&&2!==a.mergeType)if(t(a.mergeType)&&"1"===a.mergeType.trim())a.mergeType=1;else{if(!t(a.mergeType)||"2"!==a.mergeType.trim())throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof a.mergeType}", equal to ${JSON.stringify(a.mergeType,null,4)}`);a.mergeType=2}if("boolean"!=typeof a.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof a.joinRangesThatTouchEdges}", equal to ${JSON.stringify(a.joinRangesThatTouchEdges,null,4)}`)}else a={...o};const i=e.map(e=>[...e]).filter(e=>void 0!==e[2]||e[0]!==e[1]);let s,u,l;s=a.progressFn?J(i,{progressFn:e=>{l=Math.floor(e/5),l!==u&&(u=l,a.progressFn(l))}}):J(i);const f=s.length-1;for(let e=f;e>0;e--)a.progressFn&&(l=Math.floor(78*(1-e/f))+21,l!==u&&l>u&&(u=l,a.progressFn(l))),(s[e][0]<=s[e-1][0]||!a.joinRangesThatTouchEdges&&s[e][0]<s[e-1][1]||a.joinRangesThatTouchEdges&&s[e][0]<=s[e-1][1])&&(s[e-1][0]=Math.min(s[e][0],s[e-1][0]),s[e-1][1]=Math.max(s[e][1],s[e-1][1]),void 0!==s[e][2]&&(s[e-1][0]>=s[e][0]||s[e-1][1]<=s[e][1])&&null!==s[e-1][2]&&(null===s[e][2]&&null!==s[e-1][2]?s[e-1][2]=null:void 0!==s[e-1][2]?2===a.mergeType&&s[e-1][0]===s[e][0]?s[e-1][2]=s[e][2]:s[e-1][2]+=s[e][2]:s[e-1][2]=s[e][2]),s.splice(e,1),e=s.length);return s}function q(e){return null!=e}function M(e){return"string"==typeof e}var k=Array.isArray;return function(e,r){if(!k(e))return e;if(!e.length)return{};var n,o,a={wildcard:"*",dedupePlease:!0};n=null!=r?t(t({},a),r):t({},a);for(var i=(o=n.dedupePlease?P(e):Array.from(e)).length,s={},u=0;u<i;u++){var l=o[u].match(/\d+/gm);l?function(){var e=o[u].replace(/\d+/gm,n.wildcard);Object.prototype.hasOwnProperty.call(s,e)?(l.forEach((function(r,t){s[e].elementsWhichWeCanReplaceWithWildcards[t]&&r!==s[e].elementsWhichWeCanReplaceWithWildcards[t]&&(s[e].elementsWhichWeCanReplaceWithWildcards[t]=!1)})),s[e].count+=1):s[e]={count:1,elementsWhichWeCanReplaceWithWildcards:Array.from(l)}}():s[o[u]]={count:1}}var f={};return Object.keys(s).forEach((function(e){var r=e;if(k(s[e].elementsWhichWeCanReplaceWithWildcards)&&s[e].elementsWhichWeCanReplaceWithWildcards.some((function(e){return!1!==e}))){for(var t=[],o=0,a=0;a<s[e].elementsWhichWeCanReplaceWithWildcards.length;a++)o=r.indexOf(n.wildcard,o+n.wildcard.length),!1!==s[e].elementsWhichWeCanReplaceWithWildcards[a]&&t.push([o,o+n.wildcard.length,s[e].elementsWhichWeCanReplaceWithWildcards[a]]);r=function(e,r,t){let n,o=0,a=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(!M(e))throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(null===r)return e;if(!Array.isArray(r))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);if(t&&"function"!=typeof t)throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);n=Array.isArray(r)&&(Number.isInteger(r[0])&&r[0]>=0||/^\d*$/.test(r[0]))&&(Number.isInteger(r[1])&&r[1]>=0||/^\d*$/.test(r[1]))?[Array.from(r)]:Array.from(r);const i=n.length;let s=0;n.forEach((e,r)=>{if(t&&(o=Math.floor(s/i*10),o!==a&&(a=o,t(o))),!Array.isArray(e))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${r}th element not an array: ${JSON.stringify(e,null,4)}, which is ${typeof e}`);if(!Number.isInteger(e[0])||e[0]<0){if(!/^\d*$/.test(e[0]))throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${r}th element, array [${e[0]},${e[1]}]. That array has first element not an integer, but ${typeof e[0]}, equal to: ${JSON.stringify(e[0],null,4)}. Computer doesn't like this.`);n[r][0]=Number.parseInt(n[r][0],10)}if(!Number.isInteger(e[1])){if(!/^\d*$/.test(e[1]))throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${r}th element, array [${e[0]},${e[1]}]. That array has second element not an integer, but ${typeof e[1]}, equal to: ${JSON.stringify(e[1],null,4)}. Computer doesn't like this.`);n[r][1]=Number.parseInt(n[r][1],10)}s+=1});const u=x(n,{progressFn:e=>{t&&(o=10+Math.floor(e/10),o!==a&&(a=o,t(o)))}}),l=u.length;if(l>0){const r=e.slice(u[l-1][1]);e=u.reduce((r,n,i,s)=>{t&&(o=20+Math.floor(i/l*80),o!==a&&(a=o,t(o)));const u=0===i?0:s[i-1][1],f=s[i][0];return r+e.slice(u,f)+(q(s[i][2])?s[i][2]:"")},""),e+=r}return e}(r,t)}f[r]=s[e].count})),f}}));
