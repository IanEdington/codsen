{"_quickTake.js":{"title":"Extract paths of all object keys named \"foo\"","content":"import { strict as assert } from \"assert\";\nimport traverse from \"ast-monkey-traverse\";\n\nconst paths = [];\nconst source = {\n  a: {\n    foo: {\n      bar: [\n        {\n          foo: \"c\",\n        },\n      ],\n      d: {\n        e: {\n          foo: \"f\",\n        },\n      },\n    },\n  },\n};\n\ntraverse(source, (key, val, innerObj) => {\n  // if currently an object is traversed, you get both \"key\" and \"val\"\n  // if it's array, only \"key\" is present, \"val\" is undefined\n  const current = val !== undefined ? val : key;\n  if (\n    // it's object (not array)\n    val !== undefined &&\n    // and has the key we need\n    key === \"foo\"\n  ) {\n    // push the path to array in the outer scope\n    paths.push(innerObj.path);\n  }\n  return current;\n});\n\n// notice object-path notation \"a.foo.bar.0.foo\" - array segments use dots too:\nassert.deepEqual(paths, [\"a.foo\", \"a.foo.bar.0.foo\", \"a.foo.d.e.foo\"]);"},"compatible-with-object-path.js":{"title":"Stop","content":"import { strict as assert } from \"assert\";\nimport op from \"object-path\";\nimport traverse from \"ast-monkey-traverse\";\n\nconst input = { a: \"1\", b: [{ c: \"2\" }] };\nObject.freeze(input); // let's freeze it, just for fun\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => {\n  const current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n});\n\n// notice the object-path notation is \"b.0.c\" not \"b[0].c\"\nassert.deepEqual(result1, [\"a\", \"b\", \"b.0\", \"b.0.c\"]);\n\n// each reported path is fully compatible with `object-path` get() method\nassert.deepEqual(op.get(input, \"a\"), \"1\");\nassert.deepEqual(op.get(input, \"b\"), [{ c: \"2\" }]);\nassert.deepEqual(op.get(input, \"b.0\"), { c: \"2\" });\nassert.deepEqual(op.get(input, \"b.0.c\"), \"2\");"},"stopping.js":{"title":"Stop","content":"import { strict as assert } from \"assert\";\nimport traverse from \"ast-monkey-traverse\";\n\nconst input = { a: \"1\", b: { c: \"2\" } };\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => {\n  const current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n});\nassert.deepEqual(result1, [\"a\", \"b\", \"b.c\"]);\n\n// now let's stop the traversal at path \"b\" (that's real\n// path, how object-path would reference it)\nconst result2 = [];\ntraverse(input, (key1, val1, innerObj, stop) => {\n  const current = val1 !== undefined ? val1 : key1;\n  result2.push(innerObj.path);\n  if (innerObj.path === \"b\") {\n    stop.now = true; // <---------------- !!!!!!!!!!\n  }\n  return current;\n});\nassert.deepEqual(result2, [\"a\", \"b\"]);"}}