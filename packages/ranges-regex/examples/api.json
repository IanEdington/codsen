{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\nconst result = rRegex(/the/gi, oldString);\n\n// all regex matches, but in Ranges notation (see codsen.com/ranges/):\nassert.deepEqual(result, [\n  [0, 3],\n  [31, 34],\n]);\n\n// if you slice the ranges, you'll get original regex caught values:\nassert.deepEqual(\n  result.map(([from, to]) => oldString.slice(from, to)),\n  [\"The\", \"the\"]\n);"},"clashing-replacements.js":{"title":"Clashing replacement values","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\nimport &#x7B; Ranges &#x7D; from \"ranges-push\";\n\n// Two tasks:\n// 1. replace numbers with asterisks (*)\n// 2. but delete all zero chunks\n\n// tasks clash\n\nconst source = \"sequence: 1234 5678 0000 1234\";\nconst gatheredRanges = new Ranges();\n// now can push() new ranges into \"gatheredRanges\"\n\n// 1.\n\n// conceal number chunks:\nconst fix1 = rRegex(/\\d/g, source, \"*\");\n// \\d matches digit\nassert.deepEqual(fix1, [\n  [10, 14, \"****\"],\n\n  [15, 19, \"****\"],\n\n  [20, 24, \"****\"],\n\n  [25, 29, \"****\"],\n]);\n// replacement is correct:\nassert.equal(rApply(source, fix1), \"sequence: **** **** **** ****\");\n// push it in:\ngatheredRanges.push(fix1);\n\n// 2.\n\n// delete zero chunks:\nconst fix2 = rRegex(/\\b[0]+\\b/g, source);\nassert.deepEqual(fix2, [[20, 24]]);\n// deletion is correct:\nassert.equal(rApply(source, fix2), \"sequence: 1234 5678  1234\");\n// push it in:\ngatheredRanges.push(fix2);\n\n// 3. - MERGE and APPLY\n\n// what have we got in \"gatheredRanges\"?\nassert.deepEqual(gatheredRanges.current(), [\n  [10, 14, \"****\"],\n  [15, 19, \"****\"],\n  [20, 24, \"****\"],\n  [25, 29, \"****\"],\n]);\n// notice [[19, 23, \"brown\"]] is absent - \"ranges-merge\" program detected\n// we're deleting an encompassing range of indexes [12, 29] which\n// encompasses to-be-inserted values range at [19, 23] and discarded the\n// latter.\n\n// apply both fixes in one go:\nassert.equal(\n  rApply(source, gatheredRanges.current()),\n  \"sequence: **** **** **** ****\"\n);\n\n// hey, the zero chunk deletion range [20, 24] was merged with\n// replacement range [20, 24, \"****\"] and former got lost!\n\n// How do we make that the deletion would make precedence over everything\n// else?\n\n// Answer is, put `null` in replacement. It will be interpreted as explicit\n// deletion.\n\n// insert null as replacement:\nconst fix3 = rRegex(/\\b[0]+\\b/g, source, null);\nassert.deepEqual(fix3, [[20, 24, null]]);\n// deletion is correct:\nassert.equal(rApply(source, fix3), \"sequence: 1234 5678  1234\");\n\n// wipe the \"gatheredRanges\"\ngatheredRanges.wipe();\n\n// push again\ngatheredRanges.push(fix1); // asterisks\ngatheredRanges.push(fix3); // zero chunk\n\n// apply again:\nassert.equal(\n  rApply(source, gatheredRanges.current()),\n  \"sequence: **** ****  ****\"\n);\n// null in [20, 24, null] overrode the insertion instruction [20, 24, \"****\"]"},"nothing-to-find.js":{"title":"Nothing was found","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\n\nassert.equal(rRegex(/abc/g, \"xyz\"), null);\n// Falsy null means no ranges, other Ranges ecosystem\n// packages will accept null as input value\n// For the record, an empty array is truthy"},"replacement-mini.js":{"title":"Replacing values","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; rRegex &#x7D; from \"ranges-regex\";\nimport &#x7B; rApply &#x7D; from \"ranges-apply\";\n\n// Task: fix \"brow\" typo using regex and Ranges\n\nconst source = \"the typo in 'quick brow fox' sentence\";\n\n// 1. \"brow\"\nconst fix1 = rRegex(/\\bbrow\\b/g, source);\n// \\b matches word boundary\nassert.deepEqual(fix1, [[19, 23]]);\n// apply ranges to get the result string:\nassert.equal(rApply(source, fix1), \"the typo in 'quick  fox' sentence\");\n\n// But in Ranges terms, two elements mean deletion range, not replacement!\n// For replacement, you add a third element, value to put.\nconst fix2 = rRegex(/\\bbrow\\b/g, source, \"brown\");\n// \\b matches word boundary\nassert.deepEqual(fix2, [[19, 23, \"brown\"]]);\n// apply ranges to get the result string:\nassert.equal(rApply(source, fix2), \"the typo in 'quick brown fox' sentence\");"}}