/**
 * string-range-expander
 * Expands string index ranges within whitespace boundaries until letters are met
 * Version: 1.11.2
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-range-expander
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).stringRangeExpander=t()}(this,(function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function i(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}return function(n){var r,o=/^[0-9a-zA-Z]+$/;function s(e){return!(!e||"string"!=typeof e)&&!e.trim()}function c(e){return"string"==typeof e}if(!n||"object"!==e(n)||Array.isArray(n))throw r=void 0===n?"but it is missing completely.":null===n?"but it was given as null.":"but it was given as ".concat(e(n),", equal to:\n").concat(JSON.stringify(n,null,4),"."),new Error("string-range-expander: [THROW_ID_01] Input must be a plain object ".concat(r));if("object"===e(n)&&null!==n&&!Array.isArray(n)&&!Object.keys(n).length)throw new Error("string-range-expander: [THROW_ID_02] Input must be a plain object but it was given as a plain object without any keys.");if("number"!=typeof n.from)throw new Error("string-range-expander: [THROW_ID_03] The input's \"from\" value opts.from, is not a number! Currently it's given as ".concat(e(n.from),", equal to ").concat(JSON.stringify(n.from,null,0)));if("number"!=typeof n.to)throw new Error("string-range-expander: [THROW_ID_04] The input's \"to\" value opts.to, is not a number! Currently it's given as ".concat(e(n.to),", equal to ").concat(JSON.stringify(n.to,null,0)));if(!n.str[n.from]&&n.from!==n.to)throw new Error('string-range-expander: [THROW_ID_05] The given input string opts.str ("'.concat(n.str,'") must contain the character at index "from" ("').concat(n.from,'")'));if(!n.str[n.to-1])throw new Error('string-range-expander: [THROW_ID_06] The given input string, opts.str ("'.concat(n.str,'") must contain the character at index before "to" ("').concat(n.to-1,'")'));if(n.from>n.to)throw new Error('string-range-expander: [THROW_ID_07] The given "from" index, "'.concat(n.from,'" is greater than "to" index, "').concat(n.to,"\". That's wrong!"));if(c(n.extendToOneSide)&&"left"!==n.extendToOneSide&&"right"!==n.extendToOneSide||!c(n.extendToOneSide)&&void 0!==n.extendToOneSide&&!1!==n.extendToOneSide)throw new Error("string-range-expander: [THROW_ID_08] The opts.extendToOneSide value is not recogniseable! It's set to: \"".concat(n.extendToOneSide,'" (').concat(e(n.extendToOneSide),'). It has to be either Boolean "false" or strings "left" or "right"'));var l=function(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(i){t(e,i,r[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({},{str:"",from:0,to:0,ifLeftSideIncludesThisThenCropTightly:"",ifLeftSideIncludesThisCropItToo:"",ifRightSideIncludesThisThenCropTightly:"",ifRightSideIncludesThisCropItToo:"",extendToOneSide:!1,wipeAllWhitespaceOnLeft:!1,wipeAllWhitespaceOnRight:!1,addSingleSpaceToPreventAccidentalConcatenation:!1},{},n);if(Array.isArray(l.ifLeftSideIncludesThisThenCropTightly)){var f,d;if(!l.ifLeftSideIncludesThisThenCropTightly.every((function(e,t){return!!c(e)||(f=t,d=e,!1)})))throw new Error("string-range-expander: [THROW_ID_09] The opts.ifLeftSideIncludesThisThenCropTightly was set to an array:\n".concat(JSON.stringify(l.ifLeftSideIncludesThisThenCropTightly,null,4),". Now, that array contains not only string elements. For example, an element at index ").concat(f," is of a type ").concat(e(d)," (equal to ").concat(JSON.stringify(d,null,0),")."));l.ifLeftSideIncludesThisThenCropTightly=l.ifLeftSideIncludesThisThenCropTightly.join("")}var a=l.str,h=l.from,u=l.to;if("right"!==l.extendToOneSide&&(s(a[h-1])&&(s(a[h-2])||l.ifLeftSideIncludesThisCropItToo.includes(a[h-2]))||a[h-1]&&l.ifLeftSideIncludesThisCropItToo.includes(a[h-1])||l.wipeAllWhitespaceOnLeft&&s(a[h-1])))for(var T=h;T--;)if(!l.ifLeftSideIncludesThisCropItToo.includes(a[T])){if(a[T].trim()){h=l.wipeAllWhitespaceOnLeft||l.ifLeftSideIncludesThisCropItToo.includes(a[T+1])?T+1:T+2;break}if(0===T){h=l.wipeAllWhitespaceOnLeft?0:1;break}}if("left"!==l.extendToOneSide&&(s(a[u])&&(l.wipeAllWhitespaceOnRight||s(a[u+1]))||l.ifRightSideIncludesThisCropItToo.includes(a[u])))for(var p=u,g=a.length;p<g;p++)if(!l.ifRightSideIncludesThisCropItToo.includes(a[p])&&(a[p]&&a[p].trim()||void 0===a[p])){u=l.wipeAllWhitespaceOnRight||l.ifRightSideIncludesThisCropItToo.includes(a[p-1])?p:p-1;break}return("right"!==l.extendToOneSide&&c(l.ifLeftSideIncludesThisThenCropTightly)&&l.ifLeftSideIncludesThisThenCropTightly&&(a[h-2]&&l.ifLeftSideIncludesThisThenCropTightly.includes(a[h-2])||a[h-1]&&l.ifLeftSideIncludesThisThenCropTightly.includes(a[h-1]))||"left"!==l.extendToOneSide&&c(l.ifRightSideIncludesThisThenCropTightly)&&l.ifRightSideIncludesThisThenCropTightly&&(a[u+1]&&l.ifRightSideIncludesThisThenCropTightly.includes(a[u+1])||a[u]&&l.ifRightSideIncludesThisThenCropTightly.includes(a[u])))&&("right"!==l.extendToOneSide&&s(a[h-1])&&!l.wipeAllWhitespaceOnLeft&&(h-=1),"left"!==l.extendToOneSide&&s(a[u])&&!l.wipeAllWhitespaceOnRight&&(u+=1)),l.addSingleSpaceToPreventAccidentalConcatenation&&a[h-1]&&a[h-1].trim()&&a[u]&&a[u].trim()&&(!l.ifLeftSideIncludesThisThenCropTightly&&!l.ifRightSideIncludesThisThenCropTightly||l.ifLeftSideIncludesThisThenCropTightly&&!l.ifLeftSideIncludesThisThenCropTightly.includes(a[h-1])||!(!l.ifRightSideIncludesThisThenCropTightly||a[u]&&l.ifRightSideIncludesThisThenCropTightly.includes(a[u])))&&(o.test(a[h-1])||o.test(a[u]))?[h,u," "]:[h,u]}}));
