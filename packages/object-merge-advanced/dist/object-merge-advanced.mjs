/**
 * object-merge-advanced
 * Recursive, deep merge of anything (objects, arrays, strings or nested thereof), which weighs contents by type hierarchy to ensure the maximum content is retained
 * Version: 10.12.1
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/object-merge-advanced/
 */

import e from"lodash.clonedeep";import t from"lodash.includes";import n from"lodash.uniq";import y from"lodash.isplainobject";import{includesWithGlob as r}from"array-includes-with-glob";import{nonEmpty as p}from"util-nonempty";var o="10.12.1";function c(e){return"string"==typeof e}function a(e){return"boolean"==typeof e}const i=Array.isArray;function h(e){return!!e&&e.some((e=>"string"==typeof e))}function s(e,t){return 0===Object.keys(e).length||0===Object.keys(t).length||Object.keys(e).every((e=>Object.keys(t).includes(e)))||Object.keys(t).every((t=>Object.keys(e).includes(t)))}function f(e){return y(e)?"object":i(e)?"array":typeof e}const u={cb:null,mergeObjectsOnlyWhenKeysetMatches:!0,ignoreKeys:[],hardMergeKeys:[],hardArrayConcatKeys:[],mergeArraysContainingStringsToBeEmpty:!1,oneToManyArrayObjectMerge:!1,hardMergeEverything:!1,hardArrayConcat:!1,ignoreEverything:!1,concatInsteadOfMerging:!0,dedupeStringsInArrayValues:!1,mergeBoolsUsingOrNotAnd:!0,useNullAsExplicitFalse:!1};function g(o,b,l,k){const d={...u,...k};let m;if("string"==typeof d.ignoreKeys&&(d.ignoreKeys=[d.ignoreKeys]),"string"==typeof d.hardMergeKeys&&(d.hardMergeKeys=[d.hardMergeKeys]),d.hardMergeKeys.includes("*")&&(d.hardMergeEverything=!0),d.ignoreKeys.includes("*")&&(d.ignoreEverything=!0),d.useNullAsExplicitFalse&&(null===b||null===l))return"function"==typeof d.cb?d.cb(b,l,null,{path:o.path,key:o.key,type:o.type}):null;let M=i(b)||y(b)?e(b):b;const O=i(l)||y(l)?e(l):l;let A;d.ignoreEverything?A=M:d.hardMergeEverything&&(A=O);const v=d.hardMergeEverything||d.ignoreEverything;if(!i(M)){if(y(M)){if(p(M)){if(i(O)){if(p(O)){const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:m,key:o.key,type:o.type}):e}const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:m,key:o.key,type:o.type}):e}if(y(O))return Object.keys(O).forEach((e=>{m=o.path&&o.path.length?`${o.path}.${e}`:""+e,M[e]=M.hasOwnProperty(e)?r(e,d.ignoreKeys)?g({path:m,key:e,type:[f(M),f(O)]},M[e],O[e],{...d,ignoreEverything:!0}):r(e,d.hardMergeKeys)?g({path:m,key:e,type:[f(M),f(O)]},M[e],O[e],{...d,hardMergeEverything:!0}):r(e,d.hardArrayConcatKeys)?g({path:m,key:e,type:[f(M),f(O)]},M[e],O[e],{...d,hardArrayConcat:!0}):g({path:m,key:e,type:[f(M),f(O)]},M[e],O[e],d):O[e]})),M;const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}if(i(O)||y(O)||p(O)){const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}if(c(M)){if(p(M)){if((i(O)||y(O)||c(O))&&p(O)){const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}if(null!=O&&!a(O)){const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}if("number"==typeof M){if(p(O)){const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}if(a(M)){if(a(O)){if(d.mergeBoolsUsingOrNotAnd){const e=v?A:M||O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}const e=v?A:M&&O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}if(null!=O){const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}if(null===M){if(null!=O){const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}{const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:o.path,key:o.key,type:o.type}):e}}if(!p(M)){if(p(O)){const e=v?A:O;return"function"==typeof d.cb?d.cb(M,O,e,{path:m,key:o.key,type:o.type}):e}const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:m,key:o.key,type:o.type}):e}if(!i(O)||!p(O)){const e=v?A:M;return"function"==typeof d.cb?d.cb(M,O,e,{path:m,key:o.key,type:o.type}):e}{if(d.mergeArraysContainingStringsToBeEmpty&&(h(M)||h(O))){const e=v?A:[];return"function"==typeof d.cb?d.cb(M,O,e,{path:m,key:o.key,type:o.type}):e}if(d.hardArrayConcat){const e=v?A:M.concat(O);return"function"==typeof d.cb?d.cb(M,O,e,{path:m,key:o.key,type:o.type}):e}let r=[];for(let e=0,n=Math.max(M.length,O.length);n>e;e++)m=o.path&&o.path.length?`${o.path}.${e}`:""+e,y(M[e])&&y(O[e])&&(d.mergeObjectsOnlyWhenKeysetMatches&&s(M[e],O[e])||!d.mergeObjectsOnlyWhenKeysetMatches)?r.push(g({path:m,key:o.key,type:[f(M),f(O)]},M[e],O[e],d)):!d.oneToManyArrayObjectMerge||1!==M.length&&1!==O.length?d.concatInsteadOfMerging?(M.length>e&&r.push(M[e]),O.length>e&&r.push(O[e])):(M.length>e&&r.push(M[e]),O.length>e&&!t(M,O[e])&&r.push(O[e])):r.push(1===M.length?g({path:m,key:o.key,type:[f(M),f(O)]},M[0],O[e],d):g({path:m,key:o.key,type:[f(M),f(O)]},M[e],O[0],d));d.dedupeStringsInArrayValues&&r.every((e=>c(e)))&&(r=n(r).sort()),M=e(r)}const K=v?A:M;return"function"==typeof d.cb?d.cb(M,O,K,{path:o.path,key:o.key,type:o.type}):K}function b(e,t,n){if(!arguments.length)throw new TypeError("object-merge-advanced/mergeAdvanced(): [THROW_ID_01] Both inputs are missing");return g({key:null,path:"",type:[f(e),f(t)]},e,t,n)}export{u as defaults,b as mergeAdvanced,o as version};
