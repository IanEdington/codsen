{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; deepContains &#x7D; from \"ast-deep-contains\";\n\nconst gathered = [];\nconst errors = [];\n\nconst reference = [\n  &#x7B; c: \"2\" &#x7D;, // will end up not used\n  &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;,\n  &#x7B; x: \"8\", y: \"9\", z: \"0\" &#x7D;,\n];\n\nconst structureToMatch = [\n  &#x7B; a: \"1\", b: \"2\", c: \"3\" &#x7D;, // matches but has different position in the source\n  &#x7B; x: \"8\", y: \"9\" &#x7D;, // \"z\" missing\n];\n\n// This program pre-matches first, then matches objects as a set-subset\ndeepContains(\n  reference,\n  structureToMatch,\n  (leftSideVal, rightSideVal) => &#x7B;\n    // This callback does the pre-matching and picks the key pairs for you.\n    // It's up to you what you will do with left- and right-side\n    // values - we normally feed them to unit test asserts but here we just push\n    // to array:\n    gathered.push([leftSideVal, rightSideVal]);\n  &#x7D;,\n  (err) => &#x7B;\n    errors.push(err);\n  &#x7D;\n);\n\n// imagine instead of pushing pairs into array, you fed them into assert\n// function in unit tests:\nassert.deepEqual(gathered, [\n  [\"1\", \"1\"],\n  [\"2\", \"2\"],\n  [\"3\", \"3\"],\n  [\"8\", \"8\"],\n  [\"9\", \"9\"],\n]);\nassert.equal(errors.length, 0);"}}