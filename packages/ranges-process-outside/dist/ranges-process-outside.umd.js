/**
 * ranges-process-outside
 * Iterate string considering ranges, as if they were already applied
 * Version: 2.2.34
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/ranges-process-outside/
 */

!function(r,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(r="undefined"!=typeof globalThis?globalThis:r||self).rangesProcessOutside=n()}(this,(function(){"use strict";function r(n){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(r){return typeof r}:function(r){return r&&"function"==typeof Symbol&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r})(n)}function n(r,n,e){return n in r?Object.defineProperty(r,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):r[n]=e,r}function e(r,n){var e=Object.keys(r);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(r);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(r,n).enumerable}))),e.push.apply(e,t)}return e}function t(r){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?e(Object(o),!0).forEach((function(e){n(r,e,o[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(o)):e(Object(o)).forEach((function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(o,n))}))}return r}function o(r,n){return function(r){if(Array.isArray(r))return r}(r)||function(r,n){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(r)))return;var e=[],t=!0,o=!1,i=void 0;try{for(var s,a=r[Symbol.iterator]();!(t=(s=a.next()).done)&&(e.push(s.value),!n||e.length!==n);t=!0);}catch(r){o=!0,i=r}finally{try{t||null==a.return||a.return()}finally{if(o)throw i}}return e}(r,n)||s(r,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function i(r){return function(r){if(Array.isArray(r))return a(r)}(r)||function(r){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(r))return Array.from(r)}(r)||s(r)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function s(r,n){if(r){if("string"==typeof r)return a(r,n);var e=Object.prototype.toString.call(r).slice(8,-1);return"Object"===e&&r.constructor&&(e=r.constructor.name),"Map"===e||"Set"===e?Array.from(r):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?a(r,n):void 0}}function a(r,n){(null==n||n>r.length)&&(n=r.length);for(var e=0,t=new Array(n);e<n;e++)t[e]=r[e];return t}function u(r,n){if(!Array.isArray(r)||!r.length)return r;var e,o,i=t(t({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null}),n);if(i.strictlyTwoElementsInRangeArrays&&!r.filter((function(r){return r})).every((function(r,n){return 2===r.length||(e=n,o=r.length,!1)})))throw new TypeError("ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ".concat(e,"th range (").concat(JSON.stringify(r[e],null,4),") has not two but ").concat(o," elements!"));if(!r.filter((function(r){return r})).every((function(r,n){return!(!Number.isInteger(r[0])||r[0]<0||!Number.isInteger(r[1])||r[1]<0)||(e=n,!1)})))throw new TypeError("ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ".concat(e,"th range (").concat(JSON.stringify(r[e],null,4),") does not consist of only natural numbers!"));var s=Math.pow(r.filter((function(r){return r})).length,2),a=0;return Array.from(r).filter((function(r){return r})).sort((function(r,n){return i.progressFn&&(a+=1,i.progressFn(Math.floor(100*a/s))),r[0]===n[0]?r[1]<n[1]?-1:r[1]>n[1]?1:0:r[0]<n[0]?-1:1}))}function c(n,e){function o(r){return"string"==typeof r}function s(n){return n&&"object"===r(n)&&!Array.isArray(n)}if(!Array.isArray(n)||!n.length)return null;var a,c={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};if(e){if(!s(e))throw new Error("emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(e,null,4)," (type ").concat(r(e),")"));if((a=t(t({},c),e)).progressFn&&s(a.progressFn)&&!Object.keys(a.progressFn).length)a.progressFn=null;else if(a.progressFn&&"function"!=typeof a.progressFn)throw new Error('ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "'.concat(r(a.progressFn),'", equal to ').concat(JSON.stringify(a.progressFn,null,4)));if(a.mergeType&&1!==a.mergeType&&2!==a.mergeType)if(o(a.mergeType)&&"1"===a.mergeType.trim())a.mergeType=1;else{if(!o(a.mergeType)||"2"!==a.mergeType.trim())throw new Error('ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(r(a.mergeType),'", equal to ').concat(JSON.stringify(a.mergeType,null,4)));a.mergeType=2}if("boolean"!=typeof a.joinRangesThatTouchEdges)throw new Error('ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(r(a.joinRangesThatTouchEdges),'", equal to ').concat(JSON.stringify(a.joinRangesThatTouchEdges,null,4)))}else a=t({},c);for(var f,l,g,y=n.filter((function(r){return r})).map((function(r){return i(r)})).filter((function(r){return void 0!==r[2]||r[0]!==r[1]})),p=(f=a.progressFn?u(y,{progressFn:function(r){(g=Math.floor(r/5))!==l&&(l=g,a.progressFn(g))}}):u(y)).length-1,h=p;h>0;h--)a.progressFn&&(g=Math.floor(78*(1-h/p))+21)!==l&&g>l&&(l=g,a.progressFn(g)),(f[h][0]<=f[h-1][0]||!a.joinRangesThatTouchEdges&&f[h][0]<f[h-1][1]||a.joinRangesThatTouchEdges&&f[h][0]<=f[h-1][1])&&(f[h-1][0]=Math.min(f[h][0],f[h-1][0]),f[h-1][1]=Math.max(f[h][1],f[h-1][1]),void 0!==f[h][2]&&(f[h-1][0]>=f[h][0]||f[h-1][1]<=f[h][1])&&null!==f[h-1][2]&&(null===f[h][2]&&null!==f[h-1][2]?f[h-1][2]=null:void 0!==f[h-1][2]?2===a.mergeType&&f[h-1][0]===f[h][0]?f[h-1][2]=f[h][2]:f[h-1][2]+=f[h][2]:f[h-1][2]=f[h][2]),f.splice(h,1),h=f.length);return f.length?f:null}function f(n,e){if(!Array.isArray(n))throw new TypeError("ranges-crop: [THROW_ID_01] The first input's argument must be an array, consisting of range arrays! Currently its type is: ".concat(r(n),", equal to: ").concat(JSON.stringify(n,null,4)));if(!Number.isInteger(e))throw new TypeError("ranges-crop: [THROW_ID_02] The second input's argument must be a natural number or zero (coming from String.length)! Currently its type is: ".concat(r(e),", equal to: ").concat(JSON.stringify(e,null,4)));if(!n.filter((function(r){return r})).length)return n.filter((function(r){return r}));var t;if(!n.filter((function(r){return r})).every((function(r,n){return!(!Number.isInteger(r[0])||!Number.isInteger(r[1]))||(t=n,!1)}))){if(Array.isArray(n)&&"number"==typeof n[0]&&"number"==typeof n[1])throw new TypeError("ranges-crop: [THROW_ID_03] The first argument should be AN ARRAY OF RANGES, not a single range! Currently arrOfRanges = ".concat(JSON.stringify(n,null,0),"!"));throw new TypeError("ranges-crop: [THROW_ID_04] The first argument should be AN ARRAY OF ARRAYS! Each sub-array means string slice indexes. In our case, here ".concat(t+1,"th range (").concat(JSON.stringify(n[t],null,0),") does not consist of only natural numbers!"))}if(!n.filter((function(r){return r})).every((function(r,n){return null==r[2]||"string"==typeof r[2]||(t=n,!1)})))throw new TypeError("ranges-crop: [THROW_ID_05] The third argument, if present at all, should be of a string-type or null. Currently the ".concat(t,"th range ").concat(JSON.stringify(n[t],null,0)," has a argument in the range of a type ").concat(r(n[t][2])));return c(n).filter((function(r){return r[0]<=e&&(void 0!==r[2]||r[0]<e)})).map((function(r){return r[1]>e?void 0!==r[2]?[r[0],e,r[2]]:[r[0],e]:r}))}function l(n,e,o){if(!Array.isArray(n)&&null!==n)throw new TypeError("ranges-invert: [THROW_ID_01] Input's first argument must be an array, consisting of range arrays! Currently its type is: ".concat(r(n),", equal to: ").concat(JSON.stringify(n,null,4)));if(!Number.isInteger(e)||e<0)throw new TypeError("ranges-invert: [THROW_ID_02] Input's second argument must be a natural number or zero (coming from String.length)! Currently its type is: ".concat(r(e),", equal to: ").concat(JSON.stringify(e,null,4)));if(Array.isArray(n)&&"number"==typeof n[0]&&"number"==typeof n[1])throw new TypeError("ranges-invert: [THROW_ID_07] The first argument should be AN ARRAY OF RANGES, not a single range! Currently arrOfRanges = ".concat(JSON.stringify(n,null,0),"!"));if(!Array.isArray(n)||!n.filter((function(r){return Array.isArray(r)&&r[0]!==r[1]})).length||!e)return e?[[0,e]]:null;var i,s,a=t(t({},{strictlyTwoElementsInRangeArrays:!1,skipChecks:!1}),o);if(!a.skipChecks&&a.strictlyTwoElementsInRangeArrays&&!n.filter((function(r){return r})).every((function(r,n){return 2===r.length||(i=n,s=r.length,!1)})))throw new TypeError("ranges-invert: [THROW_ID_04] Because opts.strictlyTwoElementsInRangeArrays was enabled, all ranges must be strictly two-element-long. However, the ".concat(i,"th range (").concat(JSON.stringify(n[i],null,0),") has not two but ").concat(s," elements!"));if(!a.skipChecks&&!n.every((function(r,n){return!(!Number.isInteger(r[0])||r[0]<0||!Number.isInteger(r[1])||r[1]<0)||(i=n,!1)})))throw new TypeError("ranges-invert: [THROW_ID_05] The first argument should be AN ARRAY OF ARRAYS! Each sub-array means string slice indexes. In our case, here ".concat(i+1,"th range (").concat(JSON.stringify(n[i],null,0),") does not consist of only natural numbers!"));return f((a.skipChecks?n.filter((function(r){return r[0]!==r[1]})):c(n.filter((function(r){return r[0]!==r[1]})))).reduce((function(r,n,t,o){var i=[];0===t&&0!==o[0][0]&&i.push([0,o[0][0]]);var s=t<o.length-1?o[t+1][0]:e;if(n[1]!==s){if(a.skipChecks&&n[1]>s)throw new TypeError("ranges-invert: [THROW_ID_08] The checking (opts.skipChecks) is off and input ranges were not sorted! We nearly wrote range [".concat(n[1],", ").concat(s,"] which is backwards. For investigation, whole ranges array is:\n").concat(JSON.stringify(o,null,0)));i.push([n[1],s])}return r.concat(i)}),[]),e)}var g=55296,y=127995,p=127999,h=[776,2359,2359,2367,2367,2984,3007,3021,3633,3635,3648,3657,4352,4449,4520];function m(r){if("string"!=typeof r)throw new Error("string cannot be undefined or null");for(var n=[],e=0,t=0;e<r.length;)O(r[e+(t+=b(e+t,r))])&&t++,w(r[e+t])&&t++,T(r[e+t])&&t++,v(r[e+t])?t++:(n.push(r.substring(e,e+t)),e+=t,t=0);return n}function b(r,n){var e=n[r];if(!function(r){return r&&I(r[0].charCodeAt(0),g,56319)}(e)||r===n.length-1)return 1;var t=e+n[r+1],o=n.substring(r+2,r+5);return d(t)&&d(o)||function(r){return I(A(r),y,p)}(o)?4:2}function d(r){return I(A(r),127462,127487)}function w(r){return"string"==typeof r&&I(r.charCodeAt(0),65024,65039)}function T(r){return"string"==typeof r&&I(r.charCodeAt(0),8400,8447)}function O(r){return"string"==typeof r&&-1!==h.indexOf(r.charCodeAt(0))}function v(r){return"string"==typeof r&&8205===r.charCodeAt(0)}function A(r){return(r.charCodeAt(0)-g<<10)+(r.charCodeAt(1)-56320)+65536}function I(r,n,e){return r>=n&&r<=e}var R=m,E=function(r,n,e){var t=m(r);if(void 0===n)return r;if(n>=t.length)return"";var o=t.length-n,i=n+(void 0===e?o:e);return i>n+o&&(i=void 0),t.slice(n,i).join("")};return R.substr=E,function(n,e,t){var i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];function s(r){return r&&"[object Function]"==={}.toString.call(r)}if("string"!=typeof n)throw void 0===n?new Error("ranges-process-outside: [THROW_ID_01] the first input argument must be string! It's missing currently (undefined)!"):new Error("ranges-process-outside: [THROW_ID_02] the first input argument must be string! It was given as:\n".concat(JSON.stringify(n,null,4)," (type ").concat(r(n),")"));if(e&&(!Array.isArray(e)||e.length&&!Array.isArray(e[0])))throw new Error("ranges-process-outside: [THROW_ID_03] the second input argument must be array of ranges or null! It was given as:\n".concat(JSON.stringify(e,null,4)," (type ").concat(r(e),")"));if(!s(t))throw new Error("ranges-process-outside: [THROW_ID_04] the third input argument must be a function! It was given as:\n".concat(JSON.stringify(t,null,4)," (type ").concat(r(t),")"));function a(r,n){n.forEach((function(n){for(var e=o(n,2),i=e[0],s=e[1],a=i;a<s;a++){var u=R(r.slice(a))[0].length;t(a,a+u,(function(r){null!=r&&(a+=r)})),u&&u>1&&(a+=u-1)}}))}if(e&&e.length){var u=f(l(e,n.length,{skipChecks:!!i}),n.length);a(n,u)}else a(n,[[0,n.length]])}}));
