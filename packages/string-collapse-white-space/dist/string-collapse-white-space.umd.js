/**
 * string-collapse-white-space
 * Efficient collapsing of white space with optional outer- and/or line-trimming and HTML tag recognition
 * Version: 5.2.17
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-collapse-white-space
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).stringCollapseWhiteSpace=t()}(this,(function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function r(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function n(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var r=[],n=!0,i=!1,o=void 0;try{for(var s,a=e[Symbol.iterator]();!(n=(s=a.next()).done)&&(r.push(s.value),!t||r.length!==t);n=!0);}catch(e){i=!0,o=e}finally{try{n||null==a.return||a.return()}finally{if(i)throw o}}return r}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return i(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);"Object"===r&&e.constructor&&(r=e.constructor.name);if("Map"===r||"Set"===r)return Array.from(r);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return i(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function i(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function o(e,t){if(!Array.isArray(e))throw new TypeError(`ranges-sort: [THROW_ID_01] Input must be an array, consisting of range arrays! Currently its type is: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(0===e.length)return e;const r=Object.assign({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null},t);let n,i;if(r.strictlyTwoElementsInRangeArrays&&!e.every((e,t)=>2===e.length||(n=t,i=e.length,!1)))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) has not two but ${i} elements!`);if(!e.every((e,t)=>!(!Number.isInteger(e[0])||e[0]<0||!Number.isInteger(e[1])||e[1]<0)||(n=t,!1)))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${n}th range (${JSON.stringify(e[n],null,4)}) does not consist of only natural numbers!`);const o=e.length*e.length;let s=0;return Array.from(e).sort((e,t)=>(r.progressFn&&(s++,r.progressFn(Math.floor(100*s/o))),e[0]===t[0]?e[1]<t[1]?-1:e[1]>t[1]?1:0:e[0]<t[0]?-1:1))}function s(e,t){function r(e){return"string"==typeof e}function n(e){return e&&"object"==typeof e&&!Array.isArray(e)}if(!Array.isArray(e))return e;const i={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};let s;if(t){if(!n(t))throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n${JSON.stringify(t,null,4)} (type ${typeof t})`);if(s=Object.assign({},i,t),s.progressFn&&n(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&"function"!=typeof s.progressFn)throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(s.mergeType&&1!==s.mergeType&&2!==s.mergeType)if(r(s.mergeType)&&"1"===s.mergeType.trim())s.mergeType=1;else{if(!r(s.mergeType)||"2"!==s.mergeType.trim())throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);s.mergeType=2}if("boolean"!=typeof s.joinRangesThatTouchEdges)throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else s=Object.assign({},i);const a=e.map(e=>[...e]).filter(e=>void 0!==e[2]||e[0]!==e[1]);let l,u,c;l=s.progressFn?o(a,{progressFn:e=>{c=Math.floor(e/5),c!==u&&(u=c,s.progressFn(c))}}):o(a);const f=l.length-1;for(let e=f;e>0;e--)s.progressFn&&(c=Math.floor(78*(1-e/f))+21,c!==u&&c>u&&(u=c,s.progressFn(c))),(l[e][0]<=l[e-1][0]||!s.joinRangesThatTouchEdges&&l[e][0]<l[e-1][1]||s.joinRangesThatTouchEdges&&l[e][0]<=l[e-1][1])&&(l[e-1][0]=Math.min(l[e][0],l[e-1][0]),l[e-1][1]=Math.max(l[e][1],l[e-1][1]),void 0!==l[e][2]&&(l[e-1][0]>=l[e][0]||l[e-1][1]<=l[e][1])&&null!==l[e-1][2]&&(null===l[e][2]&&null!==l[e-1][2]?l[e-1][2]=null:void 0!==l[e-1][2]?2===s.mergeType&&l[e-1][0]===l[e][0]?l[e-1][2]=l[e][2]:l[e-1][2]+=l[e][2]:l[e-1][2]=l[e][2]),l.splice(e,1),e=l.length);return l}function a(e){return null!=e}function l(e){return"string"==typeof e}function u(e){return e&&"object"==typeof e&&!Array.isArray(e)}function c(e){return"string"==typeof e}function f(e,t,r,n,i,o){const s="function"==typeof r?r():r;if(t<0&&i&&"EOL"===s)return s;if(t>=e.length&&!i)return!1;let a=i?1:r.length,l=!1,u=!1,c=n.maxMismatches,f=t,g=!1,h=!1,p=!1;for(;e[f];){const t=o(f);if(n.trimBeforeMatching&&""===e[f].trim()){if(!e[t]&&i&&"EOL"===r)return!0;f=o(f);continue}if(!n.i&&n.trimCharsBeforeMatching.includes(e[f])||n.i&&n.trimCharsBeforeMatching.map(e=>e.toLowerCase()).includes(e[f].toLowerCase())){if(i&&"EOL"===r&&!e[t])return!0;f=o(f);continue}const s=t>f?r[r.length-a]:r[a-1];if(!n.i&&e[f]===s||n.i&&e[f].toLowerCase()===s.toLowerCase()){if(g||(g=!0),u||(u=!0),a===r.length?h=!0:1===a&&(p=!0),a-=1,a<1)return f}else{if(!(n.maxMismatches&&c&&f))return!(0!==f||1!==a||n.lastMustMatch||!u)&&0;c--;for(let i=0;i<=c;i++){const s=t>f?r[r.length-a+1+i]:r[a-2-i],l=e[o(f)];if(s&&(!n.i&&e[f]===s||n.i&&e[f].toLowerCase()===s.toLowerCase())&&(!n.firstMustMatch||a!==r.length)){a-=2,g=!0;break}if(l&&s&&(!n.i&&l===s||n.i&&l.toLowerCase()===s.toLowerCase())&&(!n.firstMustMatch||a!==r.length)){a-=1,g=!0;break}if(void 0===s&&c>=0&&g&&(!n.firstMustMatch||h)&&(!n.lastMustMatch||p))return f}g||(l=f)}if(!1!==l&&l!==f&&(l=!1),a<1)return f;f=o(f)}return a>0?!(!i||"EOL"!==s)||!!(n.maxMismatches>=a&&u)&&(l||0):void 0}function g(e,t,r,n){return function(e,t,r,n,i){if(u(i)&&Object.prototype.hasOwnProperty.call(i,"trimBeforeMatching")&&"boolean"!=typeof i.trimBeforeMatching)throw new Error(`string-match-left-right/${e}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(i.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);const o=Object.assign({},{i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1},i);var s;if(o.trimCharsBeforeMatching="string"==typeof(s=o.trimCharsBeforeMatching)?s.length>0?[s]:[]:s,o.trimCharsBeforeMatching=o.trimCharsBeforeMatching.map(e=>c(e)?e:String(e)),!c(t))return!1;if(!t.length)return!1;if(!Number.isInteger(r)||r<0)throw new Error(`string-match-left-right/${e}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof r}, equal to:\n${JSON.stringify(r,null,4)}`);let a,l,g,h;if(c(n))a=[n];else if(Array.isArray(n))a=n;else if(n){if("function"!=typeof n)throw new Error(`string-match-left-right/${e}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof n}, equal to:\n${JSON.stringify(n,null,4)}`);a=[],a.push(n)}else a=n;if(i&&!u(i))throw new Error(`string-match-left-right/${e}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof i}", and equal to:\n${JSON.stringify(i,null,4)}`);if(o.trimCharsBeforeMatching.some((e,t)=>e.length>1&&(g=t,h=e,!0)))throw new Error(`string-match-left-right/${e}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${g} is longer than 1 character, ${h.length} (equals to ${h}). Please split it into separate characters and put into array as separate elements.`);if(!a||!Array.isArray(a)||Array.isArray(a)&&!a.length||Array.isArray(a)&&1===a.length&&c(a[0])&&!a[0].trim()){if("function"==typeof o.cb){let n,i=r;if("matchLeftIncl"!==e&&"matchRight"!==e||(i+=1),"L"===e[5])for(let e=i;e--;){const r=t[e];if((!o.trimBeforeMatching||o.trimBeforeMatching&&void 0!==r&&r.trim())&&(!o.trimCharsBeforeMatching.length||void 0!==r&&!o.trimCharsBeforeMatching.includes(r))){n=e;break}}else if(e.startsWith("matchRight"))for(let e=i;e<t.length;e++){const r=t[e];if((!o.trimBeforeMatching||o.trimBeforeMatching&&r.trim())&&(!o.trimCharsBeforeMatching.length||!o.trimCharsBeforeMatching.includes(r))){n=e;break}}if(void 0===n)return!1;const s=t[n],a=n+1;let l="";return a&&a>0&&(l=t.slice(0,a)),"L"===e[5]?o.cb(s,l,n):(n&&n>0&&(l=t.slice(n)),o.cb(s,l,n))}let n="";throw i||(n=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${e}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${n}`)}for(let n=0,i=a.length;n<i;n++){l="function"==typeof a[n];const i=a[n];let s,u,c="",g=r;"matchRight"===e?g++:"matchLeft"===e&&g--;const h=f(t,g,i,o,l,t=>"L"===e[5]?t-1:t+1);if(h&&l&&"function"==typeof i&&"EOL"===i())return!(!i()||o.cb&&!o.cb(s,c,u))&&i();if(Number.isInteger(h)&&(u=e.startsWith("matchLeft")?h-1:h+1,c="L"===e[5]?t.slice(0,h):t.slice(u)),u<0&&(u=void 0),t[u]&&(s=t[u]),Number.isInteger(h)&&(!o.cb||o.cb(s,c,u)))return i}return!1}("matchLeftIncl",e,t,r,n)}return function(i,o){function u(e,t,r){return e.charCodeAt(0)>=t&&e.charCodeAt(0)<=r}function c(e){return"string"==typeof e&&("<"===e||!e.trim())}if("string"!=typeof i)throw new Error("string-collapse-white-space/collapse(): [THROW_ID_01] The input is not string but ".concat(e(i),", equal to: ").concat(JSON.stringify(i,null,4)));if(o&&"object"!==e(o))throw new Error("string-collapse-white-space/collapse(): [THROW_ID_02] The opts is not a plain object but ".concat(e(o),", equal to:\n").concat(JSON.stringify(o,null,4)));if(!i.length)return"";var f,h=[],p=function(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?r(Object(i),!0).forEach((function(r){t(e,r,i[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}({},{trimStart:!0,trimEnd:!0,trimLines:!1,trimnbsp:!1,recogniseHTML:!0,removeEmptyLines:!1,returnRangesOnly:!1,limitConsecutiveEmptyLinesTo:0},{},o);p.recogniseHTML&&(f=[]);var m,y=null,b=null,d=null,w=!1,O=!1,T=null,M=!1,$=!1,v={},I=!1,E=function(e){e.equalDoubleQuoteCombo=0,e.equalOnly=0,e.doubleQuoteOnly=0,e.spacesBetweenLetterChunks=0,e.linebreaks=0},_=!1;p.recogniseHTML&&E(v);for(var C=0,j=i.length;j--;){if("\n"===i[j]||"\r"===i[j]&&"\n"!==i[j+1]?C+=1:i[j].trim()&&(C=0)," "===i[j]?null===y&&(y=j):null!==y&&(j+1!==y&&h.push([j+1,y]),y=null),""===i[j].trim()&&(!p.trimnbsp&&" "!==i[j]||p.trimnbsp)){if(null===b&&(b=j),"\n"!==i[j]&&"\r"!==i[j]&&null===d&&(d=j+1),"\n"!==i[j]&&"\r"!==i[j]||(null!==d&&(p.trimLines&&h.push([j+1,d]),d=null),"\n"!==i[j-1]&&"\r"!==i[j-1]&&(d=j,w=!0)),"\n"===i[j]||"\r"===i[j]&&"\n"!==i[j+1]){var A=j+1,L=void 0;Number.isInteger(m)&&(L=m+1,p.removeEmptyLines&&void 0!==m&&""===i.slice(A,L).trim()&&C>p.limitConsecutiveEmptyLinesTo+1&&h.push([j+1,m+1])),m=j}}else null!==b&&(j+1!==b+1&&b===i.length-1&&p.trimEnd&&h.push([j+1,b+1]),b=null),null!==d&&(w&&p.trimLines&&(w=!1,d!==j+1&&h.push([j+1,d])),d=null);if(0===j&&(null!==b&&p.trimStart?h.push([0,b+1]):null!==y&&h.push([j+1,y+1])),p.recogniseHTML)if(""===i[j].trim()){if(O&&!$&&($=!0),M&&!T&&(T=j+1),M&&void 0!==i[j-1]&&""!==i[j-1].trim()&&"<"!==i[j-1]&&"/"!==i[j-1]&&(M=!1,O=!1,f=[]),!I&&!_&&""===i[j].trim()&&"<"!==i[j-1]&&(void 0===i[j+1]||""!==i[j+1].trim()&&"/"!==i[j+1].trim()))if(void 0===i[j-1]||""!==i[j-1].trim()&&"<"!==i[j-1]&&"/"!==i[j-1])v.spacesBetweenLetterChunks+=1;else for(var R=j-1;R--;)if(""!==i[R].trim()){"<"===i[R]?I=!0:"/"!==i[R]&&(v.spacesBetweenLetterChunks+=j-R);break}}else"="===i[j]?(v.equalOnly+=1,'"'===i[j+1]&&(v.equalDoubleQuoteCombo+=1)):'"'===i[j]&&(v.doubleQuoteOnly+=1),_&&(_=!1),null!==T&&(f.push([j+1,T]),T=null),">"===i[j]?(E(v),_=!0,O?f=[]:(O=!0,void 0===i[j-1]||""!==i[j-1].trim()||T||(T=j)),$||($=!0)):"<"===i[j]?(O=!1,I&&(I=!1),v.spacesBetweenLetterChunks>0&&0===v.equalDoubleQuoteCombo&&(M=!1,f=[]),M&&(f.length&&f.forEach((function(e){var t=n(e,2),r=t[0],i=t[1];return h.push([r,i])})),M=!1),E(v)):O&&"/"===i[j]?T=j:O&&!M&&($&&u(i[j],97,122)?($=!1,u(i[j],97,110)?("a"===i[j]&&("e"===i[j-1]&&g(i,j,["area","textarea"],{cb:c,i:!0})||"t"===i[j-1]&&g(i,j,["data","meta"],{cb:c,i:!0})||c(i[j-1]))||"b"===i[j]&&(g(i,j,["rb","sub"],{cb:c,i:!0})||c(i[j-1]))||"c"===i[j]&&g(i,j,"rtc",{cb:c,i:!0})||"d"===i[j]&&("a"===i[j-1]&&g(i,j,["head","thead"],{cb:c,i:!0})||g(i,j,["kbd","dd","embed","legend","td"],{cb:c,i:!0}))||"e"===i[j]&&(g(i,j,"source",{cb:c,i:!0})||"d"===i[j-1]&&g(i,j,["aside","code"],{cb:c,i:!0})||"l"===i[j-1]&&g(i,j,["table","article","title","style"],{cb:c,i:!0})||"m"===i[j-1]&&g(i,j,["iframe","time"],{cb:c,i:!0})||"r"===i[j-1]&&g(i,j,["pre","figure","picture"],{cb:c,i:!0})||"t"===i[j-1]&&g(i,j,["template","cite","blockquote"],{cb:c,i:!0})||g(i,j,"base",{cb:c,i:!0})||c(i[j-1]))||"g"===i[j]&&g(i,j,["img","strong","dialog","svg"],{cb:c,i:!0})||"h"===i[j]&&g(i,j,["th","math"],{cb:c,i:!0})||"i"===i[j]&&(g(i,j,["bdi","li"],{cb:c,i:!0})||c(i[j-1]))||"k"===i[j]&&g(i,j,["track","link","mark"],{cb:c,i:!0})||"l"===i[j]&&g(i,j,["html","ol","ul","dl","label","del","small","col"],{cb:c,i:!0})||"m"===i[j]&&g(i,j,["param","em","menuitem","form"],{cb:c,i:!0})||"n"===i[j]&&("o"===i[j-1]&&g(i,j,["section","caption","figcaption","option","button"],{cb:c,i:!0})||g(i,j,["span","keygen","dfn","main"],{cb:c,i:!0})))&&(M=!0):("o"===i[j]&&g(i,j,["bdo","video","audio"],{cb:c,i:!0})||"p"===i[j]&&(c(i[j-1])||"u"===i[j-1]&&g(i,j,["hgroup","colgroup","optgroup","sup"],{cb:c,i:!0})||g(i,j,["map","samp","rp"],{cb:c,i:!0}))||"q"===i[j]&&c(i[j-1])||"r"===i[j]&&("e"===i[j-1]&&g(i,j,["header","meter","footer"],{cb:c,i:!0})||g(i,j,["var","br","abbr","wbr","hr","tr"],{cb:c,i:!0}))||"s"===i[j]&&("s"===i[j-1]&&g(i,j,["address","progress"],{cb:c,i:!0})||g(i,j,["canvas","details","ins"],{cb:c,i:!0})||c(i[j-1]))||"t"===i[j]&&("c"===i[j-1]&&g(i,j,["object","select"],{cb:c,i:!0})||"o"===i[j-1]&&g(i,j,["slot","tfoot"],{cb:c,i:!0})||"p"===i[j-1]&&g(i,j,["script","noscript"],{cb:c,i:!0})||"u"===i[j-1]&&g(i,j,["input","output"],{cb:c,i:!0})||g(i,j,["fieldset","rt","datalist","dt"],{cb:c,i:!0}))||"u"===i[j]&&(c(i[j-1])||g(i,j,"menu",{cb:c,i:!0}))||"v"===i[j]&&g(i,j,["nav","div"],{cb:c,i:!0})||"y"===i[j]&&g(i,j,["ruby","body","tbody","summary"],{cb:c,i:!0}))&&(M=!0)):$&&u(i[j],49,54)?($=!1,"h"!==i[j-1]||"<"!==i[j-2]&&""!==i[j-2].trim()||(M=!0)):"="!==i[j]&&'"'!==i[j]||($=!1))}return p.returnRangesOnly?s(h):h.length?function(e,t,r){let n,i=0,o=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(!l(e))throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(null===t)return e;if(!Array.isArray(t))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(r&&"function"!=typeof r)throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);n=Array.isArray(t)&&(Number.isInteger(t[0])&&t[0]>=0||/^\d*$/.test(t[0]))&&(Number.isInteger(t[1])&&t[1]>=0||/^\d*$/.test(t[1]))?[Array.from(t)]:Array.from(t);const u=n.length;let c=0;n.forEach((e,t)=>{if(r&&(i=Math.floor(c/u*10),i!==o&&(o=i,r(i))),!Array.isArray(e))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${t}th element not an array: ${JSON.stringify(e,null,4)}, which is ${typeof e}`);if(!Number.isInteger(e[0])||e[0]<0){if(!/^\d*$/.test(e[0]))throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${t}th element, array [${e[0]},${e[1]}]. That array has first element not an integer, but ${typeof e[0]}, equal to: ${JSON.stringify(e[0],null,4)}. Computer doesn't like this.`);n[t][0]=Number.parseInt(n[t][0],10)}if(!Number.isInteger(e[1])){if(!/^\d*$/.test(e[1]))throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${t}th element, array [${e[0]},${e[1]}]. That array has second element not an integer, but ${typeof e[1]}, equal to: ${JSON.stringify(e[1],null,4)}. Computer doesn't like this.`);n[t][1]=Number.parseInt(n[t][1],10)}c+=1});const f=s(n,{progressFn:e=>{r&&(i=10+Math.floor(e/10),i!==o&&(o=i,r(i)))}}),g=f.length;if(g>0){const t=e.slice(f[g-1][1]);e=f.reduce((t,n,s,l)=>{r&&(i=20+Math.floor(s/g*80),i!==o&&(o=i,r(i)));const u=0===s?0:l[s-1][1],c=l[s][0];return t+e.slice(u,c)+(a(l[s][2])?l[s][2]:"")},""),e+=t}return e}(i,h):i}}));
