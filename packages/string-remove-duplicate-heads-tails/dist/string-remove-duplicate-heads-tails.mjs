/**
 * string-remove-duplicate-heads-tails
 * Detect and (recursively) remove head and tail wrappings around the input string
 * Version: 4.0.2
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-remove-duplicate-heads-tails/
 */

import t from"lodash.isplainobject";import{arrayiffy as e}from"arrayiffy-if-string";import{matchRightIncl as r,matchLeftIncl as i}from"string-match-left-right";import{Ranges as s}from"ranges-push";import{rApply as n}from"ranges-apply";import{trimSpaces as a}from"string-trim-spaces-only";var o="4.0.2";const h={heads:["{{"],tails:["}}"]};function l(o,h){const l=Object.prototype.hasOwnProperty;function c(t){return"string"==typeof t}if(void 0===o)throw Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if("string"!=typeof o)return o;if(h&&!t(h))throw Error(`string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ${typeof h}!`);if(h&&l.call(h,"heads")){if(!e(h.heads).every((t=>c(t))))throw Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");c(h.heads)&&(h.heads=e(h.heads))}if(h&&l.call(h,"tails")){if(!e(h.tails).every((t=>c(t))))throw Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");c(h.tails)&&(h.tails=e(h.tails))}const f=a(o).res;if(0===f.length)return o;o=f;const p={heads:["{{"],tails:["}}"],...h};p.heads=p.heads.map((t=>t.trim())),p.tails=p.tails.map((t=>t.trim()));let m=!1,u=!1;const d=new s({limitToBeAddedWhitespace:!0}),g=new s({limitToBeAddedWhitespace:!0});let w=!0,y=!0,b="";function B(t,e){let i;if(!r(t,0,e.heads,{trimBeforeMatching:!0,cb:(t,e,r)=>(i=r,!0)}))return t;return r(t,i,e.tails,{trimBeforeMatching:!0,cb:(t,e,r)=>(i=r,!0)})?t.slice(i):t}for(;o!==B(o,p);)o=a(B(o,p)).res;function T(t,e){let r;if(!i(t,t.length-1,e.tails,{trimBeforeMatching:!0,cb:(t,e,i)=>(r=i,!0)})||!r)return t;return i(t,r,e.heads,{trimBeforeMatching:!0,cb:(t,e,i)=>(r=i,!0)})?t.slice(0,r+1):t}for(;o!==T(o,p);)o=a(T(o,p)).res;if(!(p.heads.length&&r(o,0,p.heads,{trimBeforeMatching:!0})&&p.tails.length&&i(o,o.length-1,p.tails,{trimBeforeMatching:!0})))return a(o).res;for(let t=0,e=o.length;e>t;t++)if(""===o[t].trim());else{let e;if(r(o,t,p.heads,{trimBeforeMatching:!0,cb:(t,r,i)=>(e=i,!0)})&&e){let i;y=!0,w&&(w=!0);r(o,e,p.tails,{trimBeforeMatching:!0,cb:(t,e,r)=>(i=r,!0)})&&d.push(t,i),g.current()&&m&&"tails"!==b&&d.push(g.current()),m||g.current()&&(d.push(g.current()),g.wipe()),g.push(t,e),b="heads",t=e-1;continue}if(r(o,t,p.tails,{trimBeforeMatching:!0,cb:(t,r,i)=>(e=Number.isInteger(i)?i:o.length,!0)})&&e){y=!0,w?("heads"===b&&g.wipe(),w=!1):g.push(t,e),b="tails",t=e-1;continue}w&&(w=!0),y&&!m?(m=!0,y=!1):y&&!u?(u=!0,w=!0,y=!1,"heads"===b&&g.wipe()):y&&u&&g.wipe()}return g.current()&&d.push(g.current()),d.current()?n(o,d.current()).trim():o.trim()}export{h as defaults,l as remDup,o as version};
