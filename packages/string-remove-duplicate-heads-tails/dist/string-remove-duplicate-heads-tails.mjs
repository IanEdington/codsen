/**
 * string-remove-duplicate-heads-tails
 * Detect and (recursively) remove head and tail wrappings around the input string
 * Version: 4.0.2
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-remove-duplicate-heads-tails/
 */

import e from"lodash.isplainobject";import{arrayiffy as t}from"arrayiffy-if-string";import{matchRightIncl as r,matchLeftIncl as i}from"string-match-left-right";import{Ranges as s}from"ranges-push";import{rApply as n}from"ranges-apply";import{trimSpaces as a}from"string-trim-spaces-only";var o="4.0.2";const h={heads:["{{"],tails:["}}"]};function l(o,h){const l=Object.prototype.hasOwnProperty;function c(e){return"string"==typeof e}if(void 0===o)throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if("string"!=typeof o)return o;if(h&&!e(h))throw new Error(`string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ${typeof h}!`);const f={...h};if(f&&l.call(f,"heads")){if(!t(f.heads).every((e=>c(e))))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");c(f.heads)&&(f.heads=t(f.heads))}if(f&&l.call(f,"tails")){if(!t(f.tails).every((e=>c(e))))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");c(f.tails)&&(f.tails=t(f.tails))}const p=a(o).res;if(0===p.length)return o;o=p;const m={heads:["{{"],tails:["}}"],...f};m.heads=m.heads.map((e=>e.trim())),m.tails=m.tails.map((e=>e.trim()));let u=!1,d=!1;const g=new s({limitToBeAddedWhitespace:!0}),w=new s({limitToBeAddedWhitespace:!0});let y=!0,b=!0,B="";function T(e,t){let i;if(!r(e,0,t.heads,{trimBeforeMatching:!0,cb:(e,t,r)=>(i=r,!0)}))return e;return r(e,i,t.tails,{trimBeforeMatching:!0,cb:(e,t,r)=>(i=r,!0)})?e.slice(i):e}for(;o!==T(o,m);)o=a(T(o,m)).res;function v(e,t){let r;if(!i(e,e.length-1,t.tails,{trimBeforeMatching:!0,cb:(e,t,i)=>(r=i,!0)})||!r)return e;return i(e,r,t.heads,{trimBeforeMatching:!0,cb:(e,t,i)=>(r=i,!0)})?e.slice(0,r+1):e}for(;o!==v(o,m);)o=a(v(o,m)).res;if(!(m.heads.length&&r(o,0,m.heads,{trimBeforeMatching:!0})&&m.tails.length&&i(o,o.length-1,m.tails,{trimBeforeMatching:!0})))return a(o).res;for(let e=0,t=o.length;e<t;e++)if(""===o[e].trim());else{let t;if(r(o,e,m.heads,{trimBeforeMatching:!0,cb:(e,r,i)=>(t=i,!0)})&&t){let i;b=!0,y&&(y=!0);r(o,t,m.tails,{trimBeforeMatching:!0,cb:(e,t,r)=>(i=r,!0)})&&g.push(e,i),w.current()&&u&&"tails"!==B&&g.push(w.current()),u||w.current()&&(g.push(w.current()),w.wipe()),w.push(e,t),B="heads",e=t-1;continue}if(r(o,e,m.tails,{trimBeforeMatching:!0,cb:(e,r,i)=>(t=Number.isInteger(i)?i:o.length,!0)})&&t){b=!0,y?("heads"===B&&w.wipe(),y=!1):w.push(e,t),B="tails",e=t-1;continue}y&&(y=!0),b&&!u?(u=!0,b=!1):b&&!d?(d=!0,y=!0,b=!1,"heads"===B&&w.wipe()):b&&d&&w.wipe()}return w.current()&&g.push(w.current()),g.current()?n(o,g.current()).trim():o.trim()}export{h as defaults,l as remDup,o as version};
