/**
 * string-remove-duplicate-heads-tails
 * Detect and (recursively) remove head and tail wrappings around the input string
 * Version: 3.0.68
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://codsen.com/os/string-remove-duplicate-heads-tails/
 */

!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(t="undefined"!=typeof globalThis?globalThis:t||self).stringRemoveDuplicateHeadsTails=r()}(this,(function(){"use strict";function t(r){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(r)}function r(t,r){for(var e=0;e<r.length;e++){var n=r[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function e(t,r,e){return r in t?Object.defineProperty(t,r,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[r]=e,t}function n(t,r){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(t,r).enumerable}))),e.push.apply(e,n)}return e}function i(t){for(var r=1;r<arguments.length;r++){var i=null!=arguments[r]?arguments[r]:{};r%2?n(Object(i),!0).forEach((function(r){e(t,r,i[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):n(Object(i)).forEach((function(r){Object.defineProperty(t,r,Object.getOwnPropertyDescriptor(i,r))}))}return t}function a(t){return function(t){if(Array.isArray(t))return o(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,r){if(!t)return;if("string"==typeof t)return o(t,r);var e=Object.prototype.toString.call(t).slice(8,-1);"Object"===e&&t.constructor&&(e=t.constructor.name);if("Map"===e||"Set"===e)return Array.from(t);if("Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return o(t,r)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(t,r){(null==r||r>t.length)&&(r=t.length);for(var e=0,n=new Array(r);e<r;e++)n[e]=t[e];return n}var s,c,u=Function.prototype,l=Object.prototype,f=u.toString,h=l.hasOwnProperty,g=f.call(Object),p=l.toString,y=(s=Object.getPrototypeOf,c=Object,function(t){return s(c(t))});var m=function(r){if(!function(r){return!!r&&"object"==t(r)}(r)||"[object Object]"!=p.call(r)||function(t){var r=!1;if(null!=t&&"function"!=typeof t.toString)try{r=!!(t+"")}catch(t){}return r}(r))return!1;var e=y(r);if(null===e)return!0;var n=h.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&f.call(n)==g};function d(t){return"string"==typeof t?t.length>0?[t]:[]:t}function b(r){return r&&"object"===t(r)&&!Array.isArray(r)}function w(t){return"string"==typeof t}function v(t,r,e,n,i,a){var o="function"==typeof e?e():e;if(r<0&&i&&"EOL"===o)return o;if(r>=t.length&&!i)return!1;for(var s=i?1:e.length,c=!1,u=!1,l=n.maxMismatches,f=r,h=!1,g=!1,p=!1;t[f];){var y=a(f);if(n.trimBeforeMatching&&""===t[f].trim()){if(!t[y]&&i&&"EOL"===e)return!0;f=a(f)}else if(!n.i&&n.trimCharsBeforeMatching.includes(t[f])||n.i&&n.trimCharsBeforeMatching.map((function(t){return t.toLowerCase()})).includes(t[f].toLowerCase())){if(i&&"EOL"===e&&!t[y])return!0;f=a(f)}else{var m=y>f?e[e.length-s]:e[s-1];if(!n.i&&t[f]===m||n.i&&t[f].toLowerCase()===m.toLowerCase()){if(h||(h=!0),u||(u=!0),s===e.length?g=!0:1===s&&(p=!0),(s-=1)<1)return f}else{if(!(n.maxMismatches&&l&&f))return!(0!==f||1!==s||n.lastMustMatch||!u)&&0;l-=1;for(var d=0;d<=l;d++){var b=y>f?e[e.length-s+1+d]:e[s-2-d],w=t[a(f)];if(b&&(!n.i&&t[f]===b||n.i&&t[f].toLowerCase()===b.toLowerCase())&&(!n.firstMustMatch||s!==e.length)){s-=2,h=!0;break}if(w&&b&&(!n.i&&w===b||n.i&&w.toLowerCase()===b.toLowerCase())&&(!n.firstMustMatch||s!==e.length)){s-=1,h=!0;break}if(void 0===b&&l>=0&&h&&(!n.firstMustMatch||g)&&(!n.lastMustMatch||p))return f}h||(c=f)}if(!1!==c&&c!==f&&(c=!1),s<1)return f;f=a(f)}}return s>0?!(!i||"EOL"!==o)||!!(n.maxMismatches>=s&&u)&&(c||0):void 0}function T(r,e,n,a,o){if(b(o)&&Object.prototype.hasOwnProperty.call(o,"trimBeforeMatching")&&"boolean"!=typeof o.trimBeforeMatching)throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!").concat(Array.isArray(o.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));var s,c,u,l,f=i(i({},{i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1}),o);if(f.trimCharsBeforeMatching=d(f.trimCharsBeforeMatching),f.trimCharsBeforeMatching=f.trimCharsBeforeMatching.map((function(t){return w(t)?t:String(t)})),!w(e))return!1;if(!e.length)return!1;if(!Number.isInteger(n)||n<0)throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ").concat(t(n),", equal to:\n").concat(JSON.stringify(n,null,4)));if(w(a))s=[a];else if(Array.isArray(a))s=a;else if(a){if("function"!=typeof a)throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ").concat(t(a),", equal to:\n").concat(JSON.stringify(a,null,4)));(s=[]).push(a)}else s=a;if(o&&!b(o))throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \"").concat(t(o),'", and equal to:\n').concat(JSON.stringify(o,null,4)));if(f.trimCharsBeforeMatching.some((function(t,r){return t.length>1&&(u=r,l=t,!0)})))throw new Error("string-match-left-right/".concat(r,"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ").concat(u," is longer than 1 character, ").concat(l.length," (equals to ").concat(l,"). Please split it into separate characters and put into array as separate elements."));if(!s||!Array.isArray(s)||Array.isArray(s)&&!s.length||Array.isArray(s)&&1===s.length&&w(s[0])&&!s[0].trim()){if("function"==typeof f.cb){var h,g=n;if("matchLeftIncl"!==r&&"matchRight"!==r||(g+=1),"L"===r[5])for(var p=g;p--;){var y=e[p];if((!f.trimBeforeMatching||f.trimBeforeMatching&&void 0!==y&&y.trim())&&(!f.trimCharsBeforeMatching.length||void 0!==y&&!f.trimCharsBeforeMatching.includes(y))){h=p;break}}else if(r.startsWith("matchRight"))for(var m=g;m<e.length;m++){var T=e[m];if((!f.trimBeforeMatching||f.trimBeforeMatching&&T.trim())&&(!f.trimCharsBeforeMatching.length||!f.trimCharsBeforeMatching.includes(T))){h=m;break}}if(void 0===h)return!1;var O=e[h],A=h+1,M="";return A&&A>0&&(M=e.slice(0,A)),"L"===r[5]?f.cb(O,M,h):(h&&h>0&&(M=e.slice(h)),f.cb(O,M,h))}var _="";throw o||(_=" More so, the whole options object, the fourth input argument, is missing!"),new Error("string-match-left-right/".concat(r,'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!').concat(_))}for(var I=0,E=s.length;I<E;I++){c="function"==typeof s[I];var R=s[I],j=void 0,S=void 0,W="",B=n;"matchRight"===r?B+=1:"matchLeft"===r&&(B-=1);var D=v(e,B,R,f,c,(function(t){return"L"===r[5]?t-1:t+1}));if(D&&c&&"function"==typeof R&&"EOL"===R())return!(!R()||f.cb&&!f.cb(j,W,S))&&R();if(Number.isInteger(D)&&(S=r.startsWith("matchLeft")?D-1:D+1,W="L"===r[5]?e.slice(0,D):e.slice(S)),S<0&&(S=void 0),e[S]&&(j=e[S]),Number.isInteger(D)&&(!f.cb||f.cb(j,W,S)))return R}return!1}function O(t,r,e,n){return T("matchLeftIncl",t,r,e,n)}function A(t,r,e,n){return T("matchRightIncl",t,r,e,n)}var M="Â ";function _(t){var r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],e=arguments.length>2?arguments[2]:void 0;if(!(e.trim()||t.length&&"\n"!==e&&e!==M&&" "===(r?t[t.length-1]:t[0])||t.length&&"\n"===(r?t[t.length-1]:t[0])&&"\n"!==e&&e!==M))if(r){if(("\n"===e||e===M)&&t.length&&" "===t[t.length-1])for(;t.length&&" "===t[t.length-1];)t.pop();t.push(e===M||"\n"===e?e:" ")}else{if(("\n"===e||e===M)&&t.length&&" "===t[0])for(;t.length&&" "===t[0];)t.shift();t.unshift(e===M||"\n"===e?e:" ")}}function I(t,r){if("string"==typeof t&&t.length){var e,n,i=!1;if(t.includes("\r\n")&&(i=!0),e=r&&"number"==typeof r?r:1,""===t.trim()){var a=[];for(n=e,Array.from(t).forEach((function(t){("\n"!==t||n)&&("\n"===t&&(n-=1),_(a,!0,t))}));a.length>1&&" "===a[a.length-1];)a.pop();return a.join("")}var o=[];if(n=e,""===t[0].trim())for(var s=0,c=t.length;s<c&&!t[s].trim();s++)("\n"!==t[s]||n)&&("\n"===t[s]&&(n-=1),_(o,!0,t[s]));var u=[];if(n=e,""===t.slice(-1).trim())for(var l=t.length;l--&&!t[l].trim();)("\n"!==t[l]||n)&&("\n"===t[l]&&(n-=1),_(u,!1,t[l]));return i?"".concat(o.join("")).concat(t.trim()).concat(u.join("")).replace(/\n/g,"\r\n"):o.join("")+t.trim()+u.join("")}return t}function E(t,r){if(!Array.isArray(t)||!t.length)return t;var e,n,a=i(i({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null}),r);if(a.strictlyTwoElementsInRangeArrays&&!t.filter((function(t){return t})).every((function(t,r){return 2===t.length||(e=r,n=t.length,!1)})))throw new TypeError("ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ".concat(e,"th range (").concat(JSON.stringify(t[e],null,4),") has not two but ").concat(n," elements!"));if(!t.filter((function(t){return t})).every((function(t,r){return!(!Number.isInteger(t[0])||t[0]<0||!Number.isInteger(t[1])||t[1]<0)||(e=r,!1)})))throw new TypeError("ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ".concat(e,"th range (").concat(JSON.stringify(t[e],null,4),") does not consist of only natural numbers!"));var o=Math.pow(t.filter((function(t){return t})).length,2),s=0;return Array.from(t).filter((function(t){return t})).sort((function(t,r){return a.progressFn&&(s+=1,a.progressFn(Math.floor(100*s/o))),t[0]===r[0]?t[1]<r[1]?-1:t[1]>r[1]?1:0:t[0]<r[0]?-1:1}))}function R(r,e){function n(t){return"string"==typeof t}function o(r){return r&&"object"===t(r)&&!Array.isArray(r)}if(!Array.isArray(r)||!r.length)return null;var s,c={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};if(e){if(!o(e))throw new Error("emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(e,null,4)," (type ").concat(t(e),")"));if((s=i(i({},c),e)).progressFn&&o(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&"function"!=typeof s.progressFn)throw new Error('ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "'.concat(t(s.progressFn),'", equal to ').concat(JSON.stringify(s.progressFn,null,4)));if(s.mergeType&&1!==s.mergeType&&2!==s.mergeType)if(n(s.mergeType)&&"1"===s.mergeType.trim())s.mergeType=1;else{if(!n(s.mergeType)||"2"!==s.mergeType.trim())throw new Error('ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(t(s.mergeType),'", equal to ').concat(JSON.stringify(s.mergeType,null,4)));s.mergeType=2}if("boolean"!=typeof s.joinRangesThatTouchEdges)throw new Error('ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(t(s.joinRangesThatTouchEdges),'", equal to ').concat(JSON.stringify(s.joinRangesThatTouchEdges,null,4)))}else s=i({},c);for(var u,l,f,h=r.filter((function(t){return t})).map((function(t){return a(t)})).filter((function(t){return void 0!==t[2]||t[0]!==t[1]})),g=(u=s.progressFn?E(h,{progressFn:function(t){(f=Math.floor(t/5))!==l&&(l=f,s.progressFn(f))}}):E(h)).length-1,p=g;p>0;p--)s.progressFn&&(f=Math.floor(78*(1-p/g))+21)!==l&&f>l&&(l=f,s.progressFn(f)),(u[p][0]<=u[p-1][0]||!s.joinRangesThatTouchEdges&&u[p][0]<u[p-1][1]||s.joinRangesThatTouchEdges&&u[p][0]<=u[p-1][1])&&(u[p-1][0]=Math.min(u[p][0],u[p-1][0]),u[p-1][1]=Math.max(u[p][1],u[p-1][1]),void 0!==u[p][2]&&(u[p-1][0]>=u[p][0]||u[p-1][1]<=u[p][1])&&null!==u[p-1][2]&&(null===u[p][2]&&null!==u[p-1][2]?u[p-1][2]=null:void 0!==u[p-1][2]?2===s.mergeType&&u[p-1][0]===u[p][0]?u[p-1][2]=u[p][2]:u[p-1][2]+=u[p][2]:u[p-1][2]=u[p][2]),u.splice(p,1),p=u.length);return u.length?u:null}function j(t){return null!=t}function S(t){return Number.isInteger(t)&&t>=0}function W(t){return"string"==typeof t}function B(t){return/^\d*$/.test(t)?parseInt(t,10):t}var D=function(){function e(r){!function(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,e);var n=i(i({},{limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1}),r);if(n.mergeType&&1!==n.mergeType&&2!==n.mergeType)if(W(n.mergeType)&&"1"===n.mergeType.trim())n.mergeType=1;else{if(!W(n.mergeType)||"2"!==n.mergeType.trim())throw new Error('ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(t(n.mergeType),'", equal to ').concat(JSON.stringify(n.mergeType,null,4)));n.mergeType=2}this.opts=n}var n,o,s;return n=e,(o=[{key:"add",value:function(r,e,n){for(var i=this,o=arguments.length,s=new Array(o>3?o-3:0),c=3;c<o;c++)s[c-3]=arguments[c];if(s.length>0)throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_03] Please don't overload the add() method. From the 4th input argument onwards we see these redundant arguments: ".concat(JSON.stringify(s,null,4)));if(j(r)||j(e)){if(j(r)&&!j(e)){if(Array.isArray(r)){if(r.length){if(r.some((function(t){return Array.isArray(t)})))return void r.forEach((function(t){Array.isArray(t)&&i.add.apply(i,a(t))}));r.length>1&&S(B(r[0]))&&S(B(r[1]))&&this.add.apply(this,a(r))}return}throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set ('.concat(JSON.stringify(r,null,0),') but second-one, "to" is not (').concat(JSON.stringify(e,null,0),")"))}if(!j(r)&&j(e))throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set ('.concat(JSON.stringify(e,null,0),') but first-one, "from" is not (').concat(JSON.stringify(r,null,0),")"));var u=/^\d*$/.test(r)?parseInt(r,10):r,l=/^\d*$/.test(e)?parseInt(e,10):e;if(S(n)&&(n=String(n)),!S(u)||!S(l))throw S(u)&&u>=0?new TypeError('ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(t(l),'" equal to: ').concat(JSON.stringify(l,null,4))):new TypeError('ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(t(u),'" equal to: ').concat(JSON.stringify(u,null,4)));if(j(n)&&!W(n)&&!S(n))throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ".concat(t(n),", equal to:\n").concat(JSON.stringify(n,null,4)));if(j(this.ranges)&&Array.isArray(this.last())&&u===this.last()[1]){if(this.last()[1]=l,this.last()[2],null!==this.last()[2]&&j(n)){var f=!(j(this.last()[2])&&this.last()[2].length>0)||this.opts&&this.opts.mergeType&&1!==this.opts.mergeType?n:this.last()[2]+n;this.opts.limitToBeAddedWhitespace&&(f=I(f,this.opts.limitLinebreaksCount)),W(f)&&!f.length||(this.last()[2]=f)}}else{this.ranges||(this.ranges=[]);var h=void 0===n||W(n)&&!n.length?[u,l]:[u,l,this.opts.limitToBeAddedWhitespace?I(n,this.opts.limitLinebreaksCount):n];this.ranges.push(h)}}}},{key:"push",value:function(t,r,e){for(var n=arguments.length,i=new Array(n>3?n-3:0),a=3;a<n;a++)i[a-3]=arguments[a];this.add.apply(this,[t,r,e].concat(i))}},{key:"current",value:function(){var t=this;return null!=this.ranges?(this.ranges=R(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map((function(r){return j(r[2])?[r[0],r[1],I(r[2],t.opts.limitLinebreaksCount)]:r})):this.ranges):null}},{key:"wipe",value:function(){this.ranges=void 0}},{key:"replace",value:function(t){if(Array.isArray(t)&&t.length){if(!Array.isArray(t[0])||!S(t[0][0]))throw new Error("ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ".concat(JSON.stringify(t[0],null,4)," should be an array and its first element should be an integer, a string index."));this.ranges=Array.from(t)}else this.ranges=void 0}},{key:"last",value:function(){return void 0!==this.ranges&&Array.isArray(this.ranges)?this.ranges[this.ranges.length-1]:null}}])&&r(n.prototype,o),s&&r(n,s),e}();function N(t){return null!=t}function C(t){return"string"==typeof t}function H(r,e,n){var i,a=0,o=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(!C(r))throw new TypeError("ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ".concat(t(r),", equal to: ").concat(JSON.stringify(r,null,4)));if(e&&!Array.isArray(e))throw new TypeError("ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ".concat(t(e),", equal to: ").concat(JSON.stringify(e,null,4)));if(n&&"function"!=typeof n)throw new TypeError("ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ".concat(t(n),", equal to: ").concat(JSON.stringify(n,null,4)));if(!e||!e.filter((function(t){return t})).length)return r;var s=(i=Array.isArray(e)&&(Number.isInteger(e[0])&&e[0]>=0||/^\d*$/.test(e[0]))&&(Number.isInteger(e[1])&&e[1]>=0||/^\d*$/.test(e[1]))?[Array.from(e)]:Array.from(e)).length,c=0;i.filter((function(t){return t})).forEach((function(r,e){if(n&&(a=Math.floor(c/s*10))!==o&&(o=a,n(a)),!Array.isArray(r))throw new TypeError("ranges-apply: [THROW_ID_05] ranges array, second input arg., has ".concat(e,"th element not an array: ").concat(JSON.stringify(r,null,4),", which is ").concat(t(r)));if(!Number.isInteger(r[0])||r[0]<0){if(!/^\d*$/.test(r[0]))throw new TypeError("ranges-apply: [THROW_ID_06] ranges array, second input arg. has ".concat(e,"th element, array [").concat(r[0],",").concat(r[1],"]. That array has first element not an integer, but ").concat(t(r[0]),", equal to: ").concat(JSON.stringify(r[0],null,4),". Computer doesn't like this."));i[e][0]=Number.parseInt(i[e][0],10)}if(!Number.isInteger(r[1])){if(!/^\d*$/.test(r[1]))throw new TypeError("ranges-apply: [THROW_ID_07] ranges array, second input arg. has ".concat(e,"th element, array [").concat(r[0],",").concat(r[1],"]. That array has second element not an integer, but ").concat(t(r[1]),", equal to: ").concat(JSON.stringify(r[1],null,4),". Computer doesn't like this."));i[e][1]=Number.parseInt(i[e][1],10)}c+=1}));var u=R(i,{progressFn:function(t){n&&(a=10+Math.floor(t/10))!==o&&(o=a,n(a))}});if(!u)return r;var l=u.length;if(l>0){var f=r.slice(u[l-1][1]);r=u.reduce((function(t,e,i,s){n&&(a=20+Math.floor(i/l*80))!==o&&(o=a,n(a));var c=0===i?0:s[i-1][1],u=s[i][0];return t+r.slice(c,u)+(N(s[i][2])?s[i][2]:"")}),""),r+=f}return r}function J(r,e){if("string"!=typeof r)throw new Error("string-trim-spaces-only: [THROW_ID_01] input must be string! It was given as ".concat(t(r),", equal to:\n").concat(JSON.stringify(r,null,4)));var n,a,o=i(i({},{classicTrim:!1,cr:!1,lf:!1,tab:!1,space:!0,nbsp:!1}),e);function s(t){return o.classicTrim&&!t.trim()||!o.classicTrim&&(o.space&&" "===t||o.cr&&"\r"===t||o.lf&&"\n"===t||o.tab&&"\t"===t||o.nbsp&&"Â "===t)}if(r.length){if(s(r[0]))for(var c=0,u=r.length;c<u;c++){if(!s(r[c])){n=c;break}if(c===r.length-1)return{res:"",ranges:[[0,r.length]]}}if(s(r[r.length-1]))for(var l=r.length;l--;)if(!s(r[l])){a=l+1;break}return n?a?{res:r.slice(n,a),ranges:[[0,n],[a,r.length]]}:{res:r.slice(n),ranges:[[0,n]]}:a?{res:r.slice(0,a),ranges:[[a,r.length]]}:{res:r,ranges:[]}}return{res:"",ranges:[]}}return function(r){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function n(t){return null!=t}var a=Object.prototype.hasOwnProperty;function o(t){return"string"==typeof t}if(void 0===r)throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if("string"!=typeof r)return r;if(n(e)&&!m(e))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ".concat(t(e),"!"));if(n(e)&&a.call(e,"heads")){if(!d(e.heads).every((function(t){return o(t)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");o(e.heads)&&(e.heads=d(e.heads))}if(n(e)&&a.call(e,"tails")){if(!d(e.tails).every((function(t){return o(t)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");o(e.tails)&&(e.tails=d(e.tails))}var s=J(r).res;if(0===s.length)return r;r=s;var c={heads:["{{"],tails:["}}"]},u=i(i({},c),e);u.heads=u.heads.map((function(t){return t.trim()})),u.tails=u.tails.map((function(t){return t.trim()}));var l=!1,f=!1,h=new D({limitToBeAddedWhitespace:!0}),g=new D({limitToBeAddedWhitespace:!0}),p=!0,y=!0,b="";function w(t,r){var e;return A(t,0,r.heads,{trimBeforeMatching:!0,cb:function(t,r,n){return e=n,!0},relaxedApi:!0})&&A(t,e,r.tails,{trimBeforeMatching:!0,cb:function(t,r,n){return e=n,!0},relaxedApi:!0})?t.slice(e):t}for(;r!==w(r,u);)r=J(w(r,u)).res;function v(t,r){var e;return O(t,t.length-1,r.tails,{trimBeforeMatching:!0,cb:function(t,r,n){return e=n,!0},relaxedApi:!0})&&O(t,e,r.heads,{trimBeforeMatching:!0,cb:function(t,r,n){return e=n,!0},relaxedApi:!0})?t.slice(0,e+1):t}for(;r!==v(r,u);)r=J(v(r,u)).res;if(!(u.heads.length&&A(r,0,u.heads,{trimBeforeMatching:!0,relaxedApi:!0})&&u.tails.length&&O(r,r.length-1,u.tails,{trimBeforeMatching:!0,relaxedApi:!0})))return J(r).res;for(var T=0,M=r.length;T<M;T++)if(""===r[T].trim());else{var _=void 0,I=A(r,T,u.heads,{trimBeforeMatching:!0,cb:function(t,r,e){return _=e,!0},relaxedApi:!0});if(I){y=!0,p&&(p=!0);var E=void 0,R=A(r,_,u.tails,{trimBeforeMatching:!0,cb:function(t,r,e){return E=e,!0},relaxedApi:!0});R&&h.push(T,E),g.current()&&l&&"tails"!==b&&h.push(g.current()),l||g.current()&&(h.push(g.current()),g.wipe()),g.push(T,_),b="heads",T=_-1;continue}var j=A(r,T,u.tails,{trimBeforeMatching:!0,cb:function(t,e,i){return _=n(i)?i:r.length,!0},relaxedApi:!0});if(j){y=!0,p?("heads"===b&&g.wipe(),p=!1):g.push(T,_),b="tails",T=_-1;continue}p&&(p=!0),y&&!l?(l=!0,y=!1):y&&!f?(f=!0,p=!0,y=!1,"heads"===b&&g.wipe()):y&&f&&g.wipe()}return g.current()&&h.push(g.current()),h.current()?H(r,h.current()).trim():r.trim()}}));
