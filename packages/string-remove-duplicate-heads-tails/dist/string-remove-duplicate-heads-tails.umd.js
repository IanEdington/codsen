/**
 * string-remove-duplicate-heads-tails
 * Detect and (recursively) remove head and tail wrappings around the input string
 * Version: 3.0.66
 * Author: Roy Revelt, Codsen Ltd
 * License: MIT
 * Homepage: https://gitlab.com/codsen/codsen/tree/master/packages/string-remove-duplicate-heads-tails
 */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).stringRemoveDuplicateHeadsTails=e()}(this,(function(){"use strict";function t(e){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(e)}function e(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function r(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function n(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function i(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?n(Object(i),!0).forEach((function(e){r(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):n(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function a(t){return function(t){if(Array.isArray(t))return o(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||function(t,e){if(!t)return;if("string"==typeof t)return o(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);"Object"===r&&t.constructor&&(r=t.constructor.name);if("Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return o(t,e)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}var s,c,u=Function.prototype,l=Object.prototype,f=u.toString,h=l.hasOwnProperty,g=f.call(Object),p=l.toString,y=(s=Object.getPrototypeOf,c=Object,function(t){return s(c(t))});var m=function(e){if(!function(e){return!!e&&"object"==t(e)}(e)||"[object Object]"!=p.call(e)||function(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}(e))return!1;var r=y(e);if(null===r)return!0;var n=h.call(r,"constructor")&&r.constructor;return"function"==typeof n&&n instanceof n&&f.call(n)==g};function d(t){return"string"==typeof t?t.length>0?[t]:[]:t}function b(e){return e&&"object"===t(e)&&!Array.isArray(e)}function w(t){return"string"==typeof t}function v(t,e,r,n,i,a){var o="function"==typeof r?r():r;if(e<0&&i&&"EOL"===o)return o;if(e>=t.length&&!i)return!1;for(var s=i?1:r.length,c=!1,u=!1,l=n.maxMismatches,f=e,h=!1,g=!1,p=!1;t[f];){var y=a(f);if(n.trimBeforeMatching&&""===t[f].trim()){if(!t[y]&&i&&"EOL"===r)return!0;f=a(f)}else if(!n.i&&n.trimCharsBeforeMatching.includes(t[f])||n.i&&n.trimCharsBeforeMatching.map((function(t){return t.toLowerCase()})).includes(t[f].toLowerCase())){if(i&&"EOL"===r&&!t[y])return!0;f=a(f)}else{var m=y>f?r[r.length-s]:r[s-1];if(!n.i&&t[f]===m||n.i&&t[f].toLowerCase()===m.toLowerCase()){if(h||(h=!0),u||(u=!0),s===r.length?g=!0:1===s&&(p=!0),(s-=1)<1)return f}else{if(!(n.maxMismatches&&l&&f))return!(0!==f||1!==s||n.lastMustMatch||!u)&&0;l-=1;for(var d=0;d<=l;d++){var b=y>f?r[r.length-s+1+d]:r[s-2-d],w=t[a(f)];if(b&&(!n.i&&t[f]===b||n.i&&t[f].toLowerCase()===b.toLowerCase())&&(!n.firstMustMatch||s!==r.length)){s-=2,h=!0;break}if(w&&b&&(!n.i&&w===b||n.i&&w.toLowerCase()===b.toLowerCase())&&(!n.firstMustMatch||s!==r.length)){s-=1,h=!0;break}if(void 0===b&&l>=0&&h&&(!n.firstMustMatch||g)&&(!n.lastMustMatch||p))return f}h||(c=f)}if(!1!==c&&c!==f&&(c=!1),s<1)return f;f=a(f)}}return s>0?!(!i||"EOL"!==o)||!!(n.maxMismatches>=s&&u)&&(c||0):void 0}function T(e,r,n,a,o){if(b(o)&&Object.prototype.hasOwnProperty.call(o,"trimBeforeMatching")&&"boolean"!=typeof o.trimBeforeMatching)throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!").concat(Array.isArray(o.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));var s,c,u,l,f=i(i({},{i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1}),o);if(f.trimCharsBeforeMatching=d(f.trimCharsBeforeMatching),f.trimCharsBeforeMatching=f.trimCharsBeforeMatching.map((function(t){return w(t)?t:String(t)})),!w(r))return!1;if(!r.length)return!1;if(!Number.isInteger(n)||n<0)throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ").concat(t(n),", equal to:\n").concat(JSON.stringify(n,null,4)));if(w(a))s=[a];else if(Array.isArray(a))s=a;else if(a){if("function"!=typeof a)throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ").concat(t(a),", equal to:\n").concat(JSON.stringify(a,null,4)));(s=[]).push(a)}else s=a;if(o&&!b(o))throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \"").concat(t(o),'", and equal to:\n').concat(JSON.stringify(o,null,4)));if(f.trimCharsBeforeMatching.some((function(t,e){return t.length>1&&(u=e,l=t,!0)})))throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ").concat(u," is longer than 1 character, ").concat(l.length," (equals to ").concat(l,"). Please split it into separate characters and put into array as separate elements."));if(!s||!Array.isArray(s)||Array.isArray(s)&&!s.length||Array.isArray(s)&&1===s.length&&w(s[0])&&!s[0].trim()){if("function"==typeof f.cb){var h,g=n;if("matchLeftIncl"!==e&&"matchRight"!==e||(g+=1),"L"===e[5])for(var p=g;p--;){var y=r[p];if((!f.trimBeforeMatching||f.trimBeforeMatching&&void 0!==y&&y.trim())&&(!f.trimCharsBeforeMatching.length||void 0!==y&&!f.trimCharsBeforeMatching.includes(y))){h=p;break}}else if(e.startsWith("matchRight"))for(var m=g;m<r.length;m++){var T=r[m];if((!f.trimBeforeMatching||f.trimBeforeMatching&&T.trim())&&(!f.trimCharsBeforeMatching.length||!f.trimCharsBeforeMatching.includes(T))){h=m;break}}if(void 0===h)return!1;var O=r[h],A=h+1,_="";return A&&A>0&&(_=r.slice(0,A)),"L"===e[5]?f.cb(O,_,h):(h&&h>0&&(_=r.slice(h)),f.cb(O,_,h))}var I="";throw o||(I=" More so, the whole options object, the fourth input argument, is missing!"),new Error("string-match-left-right/".concat(e,'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!').concat(I))}for(var M=0,E=s.length;M<E;M++){c="function"==typeof s[M];var R=s[M],j=void 0,S=void 0,W="",B=n;"matchRight"===e?B+=1:"matchLeft"===e&&(B-=1);var D=v(r,B,R,f,c,(function(t){return"L"===e[5]?t-1:t+1}));if(D&&c&&"function"==typeof R&&"EOL"===R())return!(!R()||f.cb&&!f.cb(j,W,S))&&R();if(Number.isInteger(D)&&(S=e.startsWith("matchLeft")?D-1:D+1,W="L"===e[5]?r.slice(0,D):r.slice(S)),S<0&&(S=void 0),r[S]&&(j=r[S]),Number.isInteger(D)&&(!f.cb||f.cb(j,W,S)))return R}return!1}function O(t,e,r,n){return T("matchLeftIncl",t,e,r,n)}function A(t,e,r,n){return T("matchRightIncl",t,e,r,n)}function _(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=arguments.length>2?arguments[2]:void 0;if(!(r.trim()||t.length&&"\n"!==r&&" "!==r&&" "===(e?t[t.length-1]:t[0])||t.length&&"\n"===(e?t[t.length-1]:t[0])&&"\n"!==r&&" "!==r))if(e){if(("\n"===r||" "===r)&&t.length&&" "===t[t.length-1])for(;t.length&&" "===t[t.length-1];)t.pop();t.push(" "===r||"\n"===r?r:" ")}else{if(("\n"===r||" "===r)&&t.length&&" "===t[0])for(;t.length&&" "===t[0];)t.shift();t.unshift(" "===r||"\n"===r?r:" ")}}function I(t,e){if("string"==typeof t&&t.length){var r,n,i=!1;if(t.includes("\r\n")&&(i=!0),r=e&&"number"==typeof e?e:1,""===t.trim()){var a=[];for(n=r,Array.from(t).forEach((function(t){("\n"!==t||n)&&("\n"===t&&(n-=1),_(a,!0,t))}));a.length>1&&" "===a[a.length-1];)a.pop();return a.join("")}var o=[];if(n=r,""===t[0].trim())for(var s=0,c=t.length;s<c&&!t[s].trim();s++)("\n"!==t[s]||n)&&("\n"===t[s]&&(n-=1),_(o,!0,t[s]));var u=[];if(n=r,""===t.slice(-1).trim())for(var l=t.length;l--&&!t[l].trim();)("\n"!==t[l]||n)&&("\n"===t[l]&&(n-=1),_(u,!1,t[l]));return i?"".concat(o.join("")).concat(t.trim()).concat(u.join("")).replace(/\n/g,"\r\n"):o.join("")+t.trim()+u.join("")}return t}function M(t,e){if(!Array.isArray(t)||!t.length)return t;var r,n,a=i(i({},{strictlyTwoElementsInRangeArrays:!1,progressFn:null}),e);if(a.strictlyTwoElementsInRangeArrays&&!t.every((function(t,e){return 2===t.length||(r=e,n=t.length,!1)})))throw new TypeError("ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ".concat(r,"th range (").concat(JSON.stringify(t[r],null,4),") has not two but ").concat(n," elements!"));if(!t.every((function(t,e){return!(!Number.isInteger(t[0])||t[0]<0||!Number.isInteger(t[1])||t[1]<0)||(r=e,!1)})))throw new TypeError("ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ".concat(r,"th range (").concat(JSON.stringify(t[r],null,4),") does not consist of only natural numbers!"));var o=t.length*t.length,s=0;return Array.from(t).sort((function(t,e){return a.progressFn&&(s+=1,a.progressFn(Math.floor(100*s/o))),t[0]===e[0]?t[1]<e[1]?-1:t[1]>e[1]?1:0:t[0]<e[0]?-1:1}))}function E(e,r){function n(t){return"string"==typeof t}function o(e){return e&&"object"===t(e)&&!Array.isArray(e)}if(!Array.isArray(e)||!e.length)return e;var s,c={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};if(r){if(!o(r))throw new Error("emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(r,null,4)," (type ").concat(t(r),")"));if((s=i(i({},c),r)).progressFn&&o(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&"function"!=typeof s.progressFn)throw new Error('ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "'.concat(t(s.progressFn),'", equal to ').concat(JSON.stringify(s.progressFn,null,4)));if(s.mergeType&&1!==s.mergeType&&2!==s.mergeType)if(n(s.mergeType)&&"1"===s.mergeType.trim())s.mergeType=1;else{if(!n(s.mergeType)||"2"!==s.mergeType.trim())throw new Error('ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(t(s.mergeType),'", equal to ').concat(JSON.stringify(s.mergeType,null,4)));s.mergeType=2}if("boolean"!=typeof s.joinRangesThatTouchEdges)throw new Error('ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(t(s.joinRangesThatTouchEdges),'", equal to ').concat(JSON.stringify(s.joinRangesThatTouchEdges,null,4)))}else s=i({},c);for(var u,l,f,h=e.map((function(t){return a(t)})).filter((function(t){return void 0!==t[2]||t[0]!==t[1]})),g=(u=s.progressFn?M(h,{progressFn:function(t){(f=Math.floor(t/5))!==l&&(l=f,s.progressFn(f))}}):M(h)).length-1,p=g;p>0;p--)s.progressFn&&(f=Math.floor(78*(1-p/g))+21)!==l&&f>l&&(l=f,s.progressFn(f)),(u[p][0]<=u[p-1][0]||!s.joinRangesThatTouchEdges&&u[p][0]<u[p-1][1]||s.joinRangesThatTouchEdges&&u[p][0]<=u[p-1][1])&&(u[p-1][0]=Math.min(u[p][0],u[p-1][0]),u[p-1][1]=Math.max(u[p][1],u[p-1][1]),void 0!==u[p][2]&&(u[p-1][0]>=u[p][0]||u[p-1][1]<=u[p][1])&&null!==u[p-1][2]&&(null===u[p][2]&&null!==u[p-1][2]?u[p-1][2]=null:void 0!==u[p-1][2]?2===s.mergeType&&u[p-1][0]===u[p][0]?u[p-1][2]=u[p][2]:u[p-1][2]+=u[p][2]:u[p-1][2]=u[p][2]),u.splice(p,1),p=u.length);return u}function R(t){return null!=t}function j(t){return Number.isInteger(t)&&t>=0}function S(t){return"string"==typeof t}function W(t){return/^\d*$/.test(t)?parseInt(t,10):t}var B=function(){function r(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,r);var n=i(i({},{limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1}),e);if(n.mergeType&&1!==n.mergeType&&2!==n.mergeType)if(S(n.mergeType)&&"1"===n.mergeType.trim())n.mergeType=1;else{if(!S(n.mergeType)||"2"!==n.mergeType.trim())throw new Error('ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(t(n.mergeType),'", equal to ').concat(JSON.stringify(n.mergeType,null,4)));n.mergeType=2}this.opts=n}var n,o,s;return n=r,(o=[{key:"add",value:function(e,r,n){for(var i=this,o=arguments.length,s=new Array(o>3?o-3:0),c=3;c<o;c++)s[c-3]=arguments[c];if(s.length>0)throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_03] Please don't overload the add() method. From the 4th input argument onwards we see these redundant arguments: ".concat(JSON.stringify(s,null,4)));if(R(e)||R(r)){if(R(e)&&!R(r)){if(Array.isArray(e)){if(e.length){if(e.some((function(t){return Array.isArray(t)})))return void e.forEach((function(t){Array.isArray(t)&&i.add.apply(i,a(t))}));e.length>1&&j(W(e[0]))&&j(W(e[1]))&&this.add.apply(this,a(e))}return}throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set ('.concat(JSON.stringify(e,null,0),') but second-one, "to" is not (').concat(JSON.stringify(r,null,0),")"))}if(!R(e)&&R(r))throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set ('.concat(JSON.stringify(r,null,0),') but first-one, "from" is not (').concat(JSON.stringify(e,null,0),")"));var u=/^\d*$/.test(e)?parseInt(e,10):e,l=/^\d*$/.test(r)?parseInt(r,10):r;if(j(n)&&(n=String(n)),!j(u)||!j(l))throw j(u)&&u>=0?new TypeError('ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(t(l),'" equal to: ').concat(JSON.stringify(l,null,4))):new TypeError('ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(t(u),'" equal to: ').concat(JSON.stringify(u,null,4)));if(R(n)&&!S(n)&&!j(n))throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ".concat(t(n),", equal to:\n").concat(JSON.stringify(n,null,4)));if(R(this.slices)&&Array.isArray(this.last())&&u===this.last()[1]){if(this.last()[1]=l,this.last()[2],null!==this.last()[2]&&R(n)){var f=!(R(this.last()[2])&&this.last()[2].length>0)||this.opts&&this.opts.mergeType&&1!==this.opts.mergeType?n:this.last()[2]+n;this.opts.limitToBeAddedWhitespace&&(f=I(f,this.opts.limitLinebreaksCount)),S(f)&&!f.length||(this.last()[2]=f)}}else{this.slices||(this.slices=[]);var h=void 0===n||S(n)&&!n.length?[u,l]:[u,l,this.opts.limitToBeAddedWhitespace?I(n,this.opts.limitLinebreaksCount):n];this.slices.push(h)}}}},{key:"push",value:function(t,e,r){for(var n=arguments.length,i=new Array(n>3?n-3:0),a=3;a<n;a++)i[a-3]=arguments[a];this.add.apply(this,[t,e,r].concat(i))}},{key:"current",value:function(){var t=this;return null!=this.slices?(this.slices=E(this.slices,{mergeType:this.opts.mergeType}),this.opts.limitToBeAddedWhitespace?this.slices.map((function(e){return R(e[2])?[e[0],e[1],I(e[2],t.opts.limitLinebreaksCount)]:e})):this.slices):null}},{key:"wipe",value:function(){this.slices=void 0}},{key:"replace",value:function(t){if(Array.isArray(t)&&t.length){if(!Array.isArray(t[0])||!j(t[0][0]))throw new Error("ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ".concat(JSON.stringify(t[0],null,4)," should be an array and its first element should be an integer, a string index."));this.slices=Array.from(t)}else this.slices=void 0}},{key:"last",value:function(){return void 0!==this.slices&&Array.isArray(this.slices)?this.slices[this.slices.length-1]:null}}])&&e(n.prototype,o),s&&e(n,s),r}();function D(t){return null!=t}function N(t){return"string"==typeof t}function C(e,r,n){var i,a=0,o=0;if(0===arguments.length)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(!N(e))throw new TypeError("ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ".concat(t(e),", equal to: ").concat(JSON.stringify(e,null,4)));if(null===r)return e;if(!Array.isArray(r))throw new TypeError("ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ".concat(t(r),", equal to: ").concat(JSON.stringify(r,null,4)));if(n&&"function"!=typeof n)throw new TypeError("ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ".concat(t(n),", equal to: ").concat(JSON.stringify(n,null,4)));var s=(i=Array.isArray(r)&&(Number.isInteger(r[0])&&r[0]>=0||/^\d*$/.test(r[0]))&&(Number.isInteger(r[1])&&r[1]>=0||/^\d*$/.test(r[1]))?[Array.from(r)]:Array.from(r)).length,c=0;i.forEach((function(e,r){if(n&&(a=Math.floor(c/s*10))!==o&&(o=a,n(a)),!Array.isArray(e))throw new TypeError("ranges-apply: [THROW_ID_05] ranges array, second input arg., has ".concat(r,"th element not an array: ").concat(JSON.stringify(e,null,4),", which is ").concat(t(e)));if(!Number.isInteger(e[0])||e[0]<0){if(!/^\d*$/.test(e[0]))throw new TypeError("ranges-apply: [THROW_ID_06] ranges array, second input arg. has ".concat(r,"th element, array [").concat(e[0],",").concat(e[1],"]. That array has first element not an integer, but ").concat(t(e[0]),", equal to: ").concat(JSON.stringify(e[0],null,4),". Computer doesn't like this."));i[r][0]=Number.parseInt(i[r][0],10)}if(!Number.isInteger(e[1])){if(!/^\d*$/.test(e[1]))throw new TypeError("ranges-apply: [THROW_ID_07] ranges array, second input arg. has ".concat(r,"th element, array [").concat(e[0],",").concat(e[1],"]. That array has second element not an integer, but ").concat(t(e[1]),", equal to: ").concat(JSON.stringify(e[1],null,4),". Computer doesn't like this."));i[r][1]=Number.parseInt(i[r][1],10)}c+=1}));var u=E(i,{progressFn:function(t){n&&(a=10+Math.floor(t/10))!==o&&(o=a,n(a))}}),l=u.length;if(l>0){var f=e.slice(u[l-1][1]);e=u.reduce((function(t,r,i,s){n&&(a=20+Math.floor(i/l*80))!==o&&(o=a,n(a));var c=0===i?0:s[i-1][1],u=s[i][0];return t+e.slice(c,u)+(D(s[i][2])?s[i][2]:"")}),""),e+=f}return e}function H(e,r){if("string"!=typeof e)throw new Error("string-trim-spaces-only: [THROW_ID_01] input must be string! It was given as ".concat(t(e),", equal to:\n").concat(JSON.stringify(e,null,4)));var n,a,o=i(i({},{classicTrim:!1,cr:!1,lf:!1,tab:!1,space:!0,nbsp:!1}),r);function s(t){return o.classicTrim&&!t.trim()||!o.classicTrim&&(o.space&&" "===t||o.cr&&"\r"===t||o.lf&&"\n"===t||o.tab&&"\t"===t||o.nbsp&&" "===t)}if(e.length){if(s(e[0]))for(var c=0,u=e.length;c<u;c++){if(!s(e[c])){n=c;break}if(c===e.length-1)return{res:"",ranges:[[0,e.length]]}}if(s(e[e.length-1]))for(var l=e.length;l--;)if(!s(e[l])){a=l+1;break}return n?a?{res:e.slice(n,a),ranges:[[0,n],[a,e.length]]}:{res:e.slice(n),ranges:[[0,n]]}:a?{res:e.slice(0,a),ranges:[[a,e.length]]}:{res:e,ranges:[]}}return{res:"",ranges:[]}}return function(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};function n(t){return null!=t}var a=Object.prototype.hasOwnProperty;function o(t){return"string"==typeof t}if(void 0===e)throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if("string"!=typeof e)return e;if(n(r)&&!m(r))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ".concat(t(r),"!"));if(n(r)&&a.call(r,"heads")){if(!d(r.heads).every((function(t){return o(t)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");o(r.heads)&&(r.heads=d(r.heads))}if(n(r)&&a.call(r,"tails")){if(!d(r.tails).every((function(t){return o(t)})))throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");o(r.tails)&&(r.tails=d(r.tails))}var s=H(e).res;if(0===s.length)return e;e=s;var c={heads:["{{"],tails:["}}"]},u=i(i({},c),r);u.heads=u.heads.map((function(t){return t.trim()})),u.tails=u.tails.map((function(t){return t.trim()}));var l=!1,f=!1,h=new B({limitToBeAddedWhitespace:!0}),g=new B({limitToBeAddedWhitespace:!0}),p=!0,y=!0,b="";function w(t,e){var r;return A(t,0,e.heads,{trimBeforeMatching:!0,cb:function(t,e,n){return r=n,!0},relaxedApi:!0})&&A(t,r,e.tails,{trimBeforeMatching:!0,cb:function(t,e,n){return r=n,!0},relaxedApi:!0})?t.slice(r):t}for(;e!==w(e,u);)e=H(w(e,u)).res;function v(t,e){var r;return O(t,t.length-1,e.tails,{trimBeforeMatching:!0,cb:function(t,e,n){return r=n,!0},relaxedApi:!0})&&O(t,r,e.heads,{trimBeforeMatching:!0,cb:function(t,e,n){return r=n,!0},relaxedApi:!0})?t.slice(0,r+1):t}for(;e!==v(e,u);)e=H(v(e,u)).res;if(!(u.heads.length&&A(e,0,u.heads,{trimBeforeMatching:!0,relaxedApi:!0})&&u.tails.length&&O(e,e.length-1,u.tails,{trimBeforeMatching:!0,relaxedApi:!0})))return H(e).res;for(var T=0,_=e.length;T<_;T++)if(""===e[T].trim());else{var I=void 0,M=A(e,T,u.heads,{trimBeforeMatching:!0,cb:function(t,e,r){return I=r,!0},relaxedApi:!0});if(M){y=!0,p&&(p=!0);var E=void 0,R=A(e,I,u.tails,{trimBeforeMatching:!0,cb:function(t,e,r){return E=r,!0},relaxedApi:!0});R&&h.push(T,E),g.current()&&l&&"tails"!==b&&h.push(g.current()),l||g.current()&&(h.push(g.current()),g.wipe()),g.push(T,I),b="heads",T=I-1;continue}var j=A(e,T,u.tails,{trimBeforeMatching:!0,cb:function(t,r,i){return I=n(i)?i:e.length,!0},relaxedApi:!0});if(j){y=!0,p?("heads"===b&&g.wipe(),p=!1):g.push(T,I),b="tails",T=I-1;continue}p&&(p=!0),y&&!l?(l=!0,y=!1):y&&!f?(f=!0,p=!0,y=!1,"heads"===b&&g.wipe()):y&&f&&g.wipe()}return g.current()&&h.push(g.current()),h.current()?C(e,h.current()).trim():e.trim()}}));
